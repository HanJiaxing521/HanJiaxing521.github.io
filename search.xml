<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis内置数据结构之链表</title>
      <link href="/2020/02/22/Redis3/"/>
      <url>/2020/02/22/Redis3/</url>
      
        <content type="html"><![CDATA[<p>编写Redis的C语言没有内置链表数据结构，因此Redis构建了自己的链表实现。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>列表键、发布、订阅、慢查询、监视器等功能</li><li>保存多个客户端的状态信息</li><li>构建客户端输出缓冲区（output buffer）</li></ol><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>在adlist.h中，每个链表节点用一个listNode结构体表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>多个listNode通过prev和next指针组成双端链表。</p><p>在adlist.h中使用list来持有链表，方便操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>下图展示一个list结构体和三个listNode结构体组成的链表：</p><p><img src="https://s2.ax1x.com/2020/02/22/3KgJxO.png" alt="图1 由list结构和listNode结构组成的链表"></p><p>Redis链表实现的特性总结：</p><ol><li>双端：prev和next指针使得获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev和表尾节点的next都指向NULL，对链表的访问以NULL为终点。</li><li>带head和tail：程序获取表头节点和表尾节点的复杂度都为O(1)。</li><li>带链表长度计数器：使用list的len属性进行计数，程序获得节点数量的复杂度为O(1)。</li><li>多态：节点使用void*指针来保存节点值，list的dup、free、match三个属性都为函数指针，可以将其设置为类型特定函数，所以Redis链表可以用于保存各种不同类型的值并实现各种类型操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内置数据结构之简单动态字符串</title>
      <link href="/2020/02/21/Redis2/"/>
      <url>/2020/02/21/Redis2/</url>
      
        <content type="html"><![CDATA[<p><strong>简单动态字符串</strong>（simple dynamic string，以下简称<strong>SDS</strong>）是Redis的一个内置数据结构。Redis默认字符串并不是C字符串，而是SDS，Redis只会使用C字符串作为字面量用在一些无需更改字符串值的地方。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>是Redis的默认字符串表示</li><li>保存数据库中的字符串值</li><li>用作AOF缓冲区以及客户端状态中的输入缓冲区</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>SDS定义在sds.h中，以结构体的形式定义，每个sdshdr结构体表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面给出一个保存了一个5字节长度的字符串、空闲空间为0的SDS示例：</p><p><img src="https://s2.ax1x.com/2020/02/21/3u4Q74.png" alt="图1 SDS示例"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在len属性里，为空字符分配空间、添加空字符到字符串末尾等操作都由SDS函数自动完成，因此这个空字符对于SDS使用者来说可谓完全透明。遵循惯例是因为SDS可以直接重用一部分C字符串函数（比如printf）。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>C字符串不记录自身长度，在C语言中为获取字符串长度需要遍历整个字符串直到遇到‘\0’，复杂度O(N)。对于SDS来说，只需访问len属性便可获知长度，复杂度O(N)，提升了Redis的性能。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>同样由于C字符串不记录自身长度，容易因为不内置检查机制使得在操作字符串时忘记考虑空间是否足够，往往导致缓冲区溢出，比如strcat()函数就具有这个隐患。而当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足需求，不满足则自动拓展其空间才执行修改操作，因而避免缓冲区溢出问题，比如sdscat()函数。</p><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><p>C字符串在进行修改操作时，为避免缓冲区溢出或者内存泄漏，往往需要进行复杂的内存重分配，SDS由于具有free空间和len属性，使其可以通过某些优化策略来减少重分配内存的次数，从而提高性能。</p><ol><li><p>空间预分配：</p><p>用于优化SDS的字符串增长操作：SDS API先检查free是否足够，若不够，不仅分配所必须要的空间，还会分配额外的未使用空间。</p><ul><li>if 修改后的SDS长度&lt;1MB then 分配的free = 修改后的len</li><li>else then 分配的free=1MB</li></ul><p>（总空间=free+len+1byte(空字符)）</p></li><li><p>惰性空间释放</p><p>用于优化SDS字符串缩短操作：在需要对SDS进行缩短操作时，SDS API并不直接释放空闲出来的空间，而是将其归入free中，以备后面可能发生的字符串增长操作。</p><p>同时，SDS会提供API使得在需要的时候释放未使用空间，因此不用担心惰性空间释放策略会造成内存浪费。</p></li></ol><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C字符串的字符必须符合某种编码（如ASCII），并且除字符串末尾外不能包含空字符，否则会提前结束字符串的读取，这些限制使得C字符串只能保存文本数据，无法保存图片、音频等二进制数据。</p><p>所有SDS API都会以处理二进制的方式处理SDS存放在buf数组里的数据，数据原封不动进行存取，所以被称为字节数组。这也是为什么要用len存放长度的原因，在判断字符串结束时也用len而不是空字符。</p><p>这个机制使得Redis可以保存多种场景的数据。</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>SDS遵循C字符串以空字符结尾的惯例，使得SDS可以重用C语言的字符串函数库里的部分函数，避免重复写相同功能的SDS函数。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归下降语法分析器</title>
      <link href="/2020/02/14/rdcheck/"/>
      <url>/2020/02/14/rdcheck/</url>
      
        <content type="html"><![CDATA[<p>自己写的递归下降语法分析器（很遗憾没能生成语法树）<br>测试代码的链接：<a href="https://github.com/HanJiaxing521/HanJiaxing521.github.io/blob/master/2020/02/14/rdcheck/test.c" target="_blank" rel="noopener">https://github.com/HanJiaxing521/HanJiaxing521.github.io/blob/master/2020/02/14/rdcheck/test.c</a></p><pre><code>/*** rdcheck.cpp: Don&apos;t generate syntax tree* author: Justin Han* time: 2019/11/22*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;/*** define the VN*/#define A program#define A1 A1#define B external_declaration#define C decl_or_stmt#define C1 C1#define D declarator_list#define D1 D1#define E intstr_list#define E1 E1#define F initializer#define G declarator#define G1 G1#define G2 G2#define G3 G3#define G4 G4#define H parameter_list#define H1 H1#define I parameter#define J Type#define K statement#define K1 K1#define K2 K2#define K3 K3#define L statement_list#define L1 L1#define M expression_statement#define N expr#define O cmp_expr#define O1 O1#define P add_expr#define P1 P1#define P2 P2#define Q mul_expr#define Q1 Q1#define Q2 Q2#define R primary_expr#define R1 R1#define R2 R2#define R3 R3#define S expr_list#define S1 S1#define T id_list#define T1 T1/*** define class-numbers of symbols*/#define ALPHABET 0#define DEGIT 1#define WHITESPACE 2#define SEPCHAR 3#define MATHCHAR 4#define STRING 5/*** define classes of symbols*/const char alphabet[52] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos; };const char degit[10] = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos; };const char whitespace[3] = { &apos; &apos;, &apos;\n&apos;, &apos;\t&apos; };const char sepchar[10] = { &apos;{&apos;, &apos;}&apos;, &apos;;&apos;, &apos;,&apos;, &apos;.&apos;, &apos;(&apos;, &apos;)&apos; ,&apos;&quot;&apos;, &apos;[&apos;, &apos;]&apos; };const char mathchar[9] = { &apos;&gt;&apos;, &apos;&lt;&apos;, &apos;=&apos;, &apos;+&apos;, &apos;-&apos;, &apos;|&apos;, &apos;/&apos;, &apos;*&apos;, &apos;%&apos; };/*define class-numbers of words* INT 19* FLOAT 20* STRING 21* SPECIAL_WORD sepchar_subscript_index+30* MATHCHAR mathchar_subscript_index+40* ID 22* annotation 23*//*** define IDs and mathwords */const char* tokens[19] = { &quot;args&quot;, &quot;class&quot;, &quot;else&quot;, &quot;for&quot;, &quot;if&quot;, &quot;int&quot;, &quot;main&quot;, &quot;new&quot;, &quot;out&quot;, &quot;package&quot;, &quot;private&quot;, &quot;public&quot;, &quot;print&quot;, &quot;println&quot;, &quot;return&quot;, &quot;static&quot;, &quot;String&quot;, &quot;System&quot;, &quot;void&quot; };const char* mathWords[17] = { &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;=&quot;, &quot;+&quot;, &quot;-&quot;, &quot;|&quot;, &quot;/&quot;, &quot;*&quot;, &quot;%&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;++&quot;, &quot;--&quot;, &quot;==&quot; ,&quot;||&quot;, &quot;-=&quot;, &quot;+=&quot; };/*** define the VT* n NUMBER* s STRING* i ID* a INT* b STR* c VOID* d IF* e ELSE* f WHILE* g RETURN* h PRINT* j SCAN* k CMP* l ASSIGN*//*** Define the FIRST set*/const char FIRST_A[3] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos; };const char FIRST_A1[4] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;\n&apos; };const char FIRST_B[3] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos; };const char FIRST_C[3] = { &apos;{&apos;,&apos;,&apos;,&apos;;&apos; };const char FIRST_C1[16] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos;,&apos;}&apos; };const char FIRST_D[1] = { &apos;i&apos; };const char FIRST_D1[2] = { &apos;,&apos;,&apos;\n&apos; };const char FIRST_E[2] = { &apos;n&apos;,&apos;s&apos; };const char FIRST_E1[2] = { &apos;,&apos;, &apos;\n&apos; };const char FIRST_F[2] = { &apos;n&apos;,&apos;s&apos; };const char FIRST_G[1] = { &apos;i&apos; };const char FIRST_G1[4] = { &apos;=&apos;,&apos;(&apos;,&apos;[&apos;,&apos;\n&apos; };const char FIRST_G2[4] = { &apos;)&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos; };const char FIRST_G3[6] = { &apos;]&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_G4[2] = { &apos;{&apos;,&apos;\n&apos; };const char FIRST_H[3] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos; };const char FIRST_H1[2] = { &apos;,&apos;,&apos;\n&apos; };const char FIRST_I[3] = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;};const char FIRST_J[3] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos; };const char FIRST_K[15] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FIRST_K1[2] = { &apos;e&apos;,&apos;\n&apos; };const char FIRST_K2[] = { &apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_K3[] = { &apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_L[] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FIRST_L1[] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; ,&apos;\n&apos; };const char FIRST_M[] = { &apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_N[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_O[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_O1[] = { &apos;k&apos;,&apos;\n&apos; };const char FIRST_P[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_P1[] = { &apos;+&apos;,&apos;-&apos; };const char FIRST_P2[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;+&apos;};const char FIRST_Q[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_Q1[] = { &apos;*&apos;,&apos;/&apos;,&apos;%&apos; };const char FIRST_Q2[] = { &apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;\n&apos; };const char FIRST_R[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos; };const char FIRST_R1[] = { &apos;(&apos;,&apos;l&apos;,&apos;=&apos;,&apos;[&apos;,&apos;\n&apos; };const char FIRST_R2[] = { &apos;i&apos;,&apos;(&apos;,&apos;)&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_R3[] = { &apos;=&apos;,&apos;\n&apos; };const char FIRST_S[] = { &apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos; };const char FIRST_S1[] = { &apos;,&apos;,&apos;\n&apos; };const char FIRST_T[] = { &apos;i&apos; };const char FIRST_T1[] = { &apos;,&apos;,&apos;\n&apos; };/*** Define the FOLLOW set*/const char FOLLOW_A[] = { &apos;#&apos; };const char FOLLOW_A1[] = { &apos;#&apos; };const char FOLLOW_B[] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;#&apos; };const char FOLLOW_C[] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;#&apos; };const char FOLLOW_C1[] = { &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;#&apos; };const char FOLLOW_D[] = { &apos;;&apos; };const char FOLLOW_D1[] = { &apos;;&apos; };const char FOLLOW_E[] = { &apos;}&apos; };const char FOLLOW_E1[] = { &apos;}&apos; };const char FOLLOW_F[] = { &apos;}&apos;,&apos;,&apos; };const char FOLLOW_G[] = { &apos;;&apos;,&apos;{&apos;,&apos;,&apos; };const char FOLLOW_G1[] = { &apos;;&apos;,&apos;{&apos;,&apos;,&apos; };const char FOLLOW_G2[] = { &apos;;&apos;,&apos;{&apos;,&apos;,&apos; };const char FOLLOW_G3[] = { &apos;;&apos;,&apos;{&apos;,&apos;,&apos; };const char FOLLOW_G4[] = { &apos;;&apos;,&apos;{&apos;,&apos;,&apos; };const char FOLLOW_H[] = { &apos;)&apos; };const char FOLLOW_H1[] = { &apos;)&apos; };const char FOLLOW_I[] = { &apos;,&apos;,&apos;)&apos; };const char FOLLOW_J[] = { &apos;i&apos; };const char FOLLOW_K[] = { &apos;}&apos;,&apos;e&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FOLLOW_K1[] = { &apos;}&apos;,&apos;e&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FOLLOW_K2[] = { &apos;}&apos;,&apos;e&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FOLLOW_K3[] = { &apos;}&apos;,&apos;e&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FOLLOw_L[] = { &apos;}&apos; };const char FOLLOW_L1[] = { &apos;}&apos; };const char FOLLOW_M[] = { &apos;}&apos;,&apos;e&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;{&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;d&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;j&apos; };const char FOLLOW_N[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_O[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_O1[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_P[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_P1[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_P2[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;{&apos;,&apos;,&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos; ,&apos;+&apos; };const char FOLLOW_Q[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos;,&apos;+&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos; };const char FOLLOW_Q1[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos;,&apos;+&apos; };const char FOLLOW_Q2[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos;,&apos;+&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos; };const char FOLLOW_R[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos; ,&apos;+&apos;};const char FOLLOW_R1[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos; ,&apos;+&apos;};const char FOLLOW_R2[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos; ,&apos;+&apos;};const char FOLLOW_R3[] = { &apos;]&apos;,&apos;)&apos;,&apos;;&apos;,&apos;*&apos;,&apos;/&apos;,&apos;%&apos;,&apos;i&apos;,&apos;(&apos;,&apos;n&apos;,&apos;s&apos;,&apos;-&apos;,&apos;k&apos;,&apos;{&apos;,&apos;,&apos; ,&apos;+&apos;};const char FOLLOW_S[] = { &apos;;&apos;,&apos;)&apos; };const char FOLLOW_S1[] = { &apos;;&apos;,&apos;)&apos; };const char FOLLOW_T[] = { &apos;;&apos; };const char FOLLOW_T1[] = { &apos;;&apos; };/*** The symbolList, symbol to be matched and its index*/char sym = &apos;0&apos;;int i = 0;char result[5000];/*** transform char to string*/char* toString(char ch){    char str[2];    str[0] = ch;    str[1] = 0;    return str;}/*** generate symbols*/char* token(char* symbol, int charClass){    char ch = &apos;0&apos;;    if (charClass == 0)        if (strcmp(symbol, &quot;int&quot;) == 0)            ch = &apos;a&apos;;        else if (strcmp(symbol, &quot;str&quot;) == 0)            ch = &apos;b&apos;;        else if (strcmp(symbol, &quot;void&quot;) == 0)            ch = &apos;c&apos;;        else if (strcmp(symbol, &quot;if&quot;) == 0)            ch = &apos;d&apos;;        else if (strcmp(symbol, &quot;else&quot;) == 0)            ch = &apos;e&apos;;        else if (strcmp(symbol, &quot;while&quot;) == 0)            ch = &apos;f&apos;;        else if (strcmp(symbol, &quot;return&quot;) == 0)            ch = &apos;g&apos;;        else if (strcmp(symbol, &quot;print&quot;) == 0)            ch = &apos;h&apos;;        else if (strcmp(symbol, &quot;scan&quot;) == 0)            ch = &apos;j&apos;;        else            ch = &apos;i&apos;;    else if (charClass == 11 || charClass == 12)        ch = &apos;n&apos;;    else if (charClass == 3)    {        for (int i = 0; i &lt; 10; i++)            if (strcmp(symbol, toString(sepchar[i])) == 0)            {                ch = sepchar[i];            }    }    else if (charClass == 4)    {        for (int i = 0; i &lt; 17; i++)            if (strcmp(symbol, &quot;&gt;&quot;) == 0 || strcmp(symbol, &quot;&lt;&quot;) == 0 || strcmp(symbol, &quot;&gt;=&quot;) == 0 || strcmp(symbol, &quot;&lt;=&quot;) == 0 || strcmp(symbol, &quot;==&quot;) == 0)                ch = &apos;k&apos;;            else if (strcmp(symbol, mathWords[i]) == 0)            {                ch = mathWords[i][0];                break;            }    }    else if (charClass == 5)        ch = &apos;s&apos;;    return toString(ch);}// Judge class-names of symbolsint type(char ch){    for (int i = 0; i &lt; 52; i++)        if (ch == alphabet[i])            return ALPHABET;    for (int i = 0; i &lt; 10; i++)        if (ch == degit[i])            return DEGIT;    for (int i = 0; i &lt; 3; i++)        if (ch == whitespace[i])            return WHITESPACE;    for (int i = 0; i &lt; 10; i++)        if (ch == sepchar[i])            if (ch == &apos;&quot;&apos;)                 return STRING;            else                return SEPCHAR;    for (int i = 0; i &lt; 9; i++)        if (ch == mathchar[i])            return MATHCHAR;}/*** generate symbolList*/char* tokenise(char* symbolList, char* symbol, char* fileName){    FILE* fp;    char ch;    //如果没有找到文件，给出提升并退出    if ((fp = fopen(fileName, &quot;rt&quot;)) == NULL)    {        printf(&quot;没有找到文件，按任意键退出&quot;);        getchar();        exit(1);    }    ch = fgetc(fp);    while (ch != EOF)    {        switch (type(ch))        {        case WHITESPACE:            ch = fgetc(fp);            break;        case ALPHABET:            strcat(symbol, toString(ch));            ch = fgetc(fp);            while (type(ch) == 0 || type(ch) == 1)            {                strcat(symbol, toString(ch));                ch = fgetc(fp);            }            strcat(symbolList, token(symbol, ALPHABET));            symbol[0] = &apos;\0&apos;;            break;        case DEGIT:            strcat(symbol, toString(ch));            ch = fgetc(fp);            int isFloat = 11;            while (type(ch) == 1)            {                strcat(symbol, toString(ch));                ch = fgetc(fp);            }            if (ch == &apos;.&apos;)            {                isFloat = 12;                strcat(symbol, toString(ch));                ch = fgetc(fp);                while (type(ch) == 1)                {                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                }            }            strcat(symbolList, token(symbol, isFloat));            symbol[0] = &apos;\0&apos;;            break;        case MATHCHAR:            strcat(symbol, toString(ch));            ch = fgetc(fp);            if (type(ch) == 4)            {                strcat(symbol, toString(ch));                ch = fgetc(fp);            }            if (strcmp(symbol, &quot;//&quot;) == 0)                while (ch != &apos;\n&apos;)                    ch = fgetc(fp);            else                strcat(symbolList, token(symbol, MATHCHAR));            symbol[0] = &apos;\0&apos;;            break;        case SEPCHAR:            strcat(symbol, toString(ch));            ch = fgetc(fp);            strcat(symbolList, token(symbol, SEPCHAR));            symbol[0] = &apos;\0&apos;;            break;        case STRING:            ch = fgetc(fp);            while (ch != &apos;&quot;&apos;)            {                strcat(symbol, toString(ch));                ch = fgetc(fp);            }            strcat(symbolList, token(symbol, STRING));            ch = fgetc(fp);            symbol[0] = &apos;\0&apos;;            break;        default:            printf(&quot;ERROR: Unknown Char: %c\n&quot;, ch);            ch = fgetc(fp);            break;        }    }    fclose(fp);    strcat(symbolList, &quot;#&quot;);    return symbolList;}/*** Judge if an atom in an array*/int isIn(char ch, char array[], int len){    for (int i = 0; i &lt; len; i++)    {        if (ch == array[i])            return 1;    }    return 0;}/*** take the next symbol*/void advance(){    sym = result[i];    printf(&quot;%c&quot;, sym);    i++;}/*** error function*/void error(){    printf(&quot;error&quot;);    exit(0);}/*** define the generation functions*/void A();void A1();void B();void C();void C1();void D();void D1();void E();void E1();void F();void G();void G1();void G2();void G3();void G4();void H();void H1();void I();void J();void K();void K1();void K2();void K3();void L();void L1();void M();void N();void O();void O1();void P();void P1();void P2();void Q();void Q1();void Q2();void R();void R1();void R2();void R3();void S();void S1();void T();void T1();void J(){    if (sym == &apos;a&apos;)        advance();    else if (sym == &apos;b&apos;)        advance();    else if (sym == &apos;c&apos;)        advance();    else        error();}void I(){    J();    if (sym == &apos;i&apos;)        advance();    else        error();}void H1(){    if (sym == &apos;,&apos;)    {        advance();        I();        H1();    }    else if (isIn(sym, FOLLOW_H1, sizeof(FOLLOW_H1)/sizeof(FOLLOW_H1[0])))        ;    else        error();}void H(){    I();    H1();}void G4(){    if (sym == &apos;=&apos;)    {        advance();        if (sym == &apos;{&apos;)            advance();        else            error();        E();        if (sym == &apos;}&apos;)            advance();        else            error();    }    else if (isIn(sym, FOLLOW_G4, sizeof(FOLLOW_G4)/sizeof(FOLLOW_G4[0])))        ;    else        error();}void G3(){    if (isIn(sym, FIRST_N, sizeof(FIRST_N)/sizeof(FIRST_N[0])))    {        N();        if (sym == &apos;]&apos;)            advance();        else            error();        G4();    }    else if (sym == &apos;]&apos;)    {        advance();        G4();    }    else        error();}void G2(){    if (isIn(sym, FIRST_H, sizeof(FIRST_H)/sizeof(FIRST_H[1])))    {        H();        if (sym == &apos;)&apos;)            advance();        else            error();    }    else if (sym == &apos;)&apos;)        advance();    else        error();}void G1(){    if (sym == &apos;=&apos;)    {        advance();        N();    }    else if (sym == &apos;(&apos;)    {        advance();        G2();    }    else if (sym == &apos;[&apos;)    {        advance();        G3();    }    else if (isIn(sym, FOLLOW_G1, sizeof(FOLLOW_G1)/sizeof(FOLLOW_G1[0])))        ;    else        error();}void G(){    if (sym == &apos;i&apos;)    {        advance();        G1();    }    else        error();}void D1(){    if (sym == &apos;,&apos;)    {        advance();        G();        D1();    }    else if (isIn(sym, FOLLOW_D1, sizeof(FOLLOW_D1)/sizeof(FOLLOW_D1[0])))        ;    else        error();}void D(){    G();    D1();}void K3(){    if (sym == &apos;;&apos;)        advance();    else if (isIn(sym, FIRST_S, sizeof(FIRST_S)/sizeof(FIRST_S[0])))    {        S();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else        error();}void K2(){    if (sym == &apos;;&apos;)        advance();    else if (isIn(sym, FIRST_N, sizeof(FIRST_N)/sizeof(FIRST_N[0])))    {        N();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else        error();}void K(){    if (isIn(sym, FIRST_J, sizeof(FIRST_J)/sizeof(FIRST_J[0])))    {        J();        D();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else if (sym == &apos;{&apos;)    {        advance();        L();        if (sym == &apos;}&apos;)            advance();        else            error();    }    else if (isIn(sym, FIRST_M, sizeof(FIRST_M)/sizeof(FIRST_M[0])))        M();    else if (sym == &apos;d&apos;)    {        advance();        if (sym == &apos;(&apos;)            advance();        else            error();        N();        if (sym == &apos;)&apos;)            advance();        else            error();        K();        K1();    }    else if (sym == &apos;f&apos;)    {        advance();        if (sym == &apos;(&apos;)            advance();        else            error();        N();        if (sym == &apos;)&apos;)            advance();        else            error();        K();    }    else if (sym == &apos;g&apos;)    {        advance();        K2();    }    else if (sym == &apos;h&apos;)    {        advance();        K3();    }    else if (sym == &apos;j&apos;)    {        advance();        T();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else        error();}void K1(){    if (sym == &apos;e&apos;)    {        advance();        K();    }    else if (isIn(sym, FOLLOW_K1, sizeof(FOLLOW_K1)/sizeof(FOLLOW_K1[0])))        ;    else        error();}void L1(){    if (isIn(sym, FIRST_K, sizeof(FIRST_K)/sizeof(FIRST_K[0])))    {        K();        L1();    }    else if (isIn(sym, FOLLOW_L1, sizeof(FOLLOW_L1)/sizeof(FOLLOW_L1[0])))        ;    else        error();}void L(){    K();    L1();}void F(){    if (sym == &apos;n&apos;)        advance();    else if (sym == &apos;s&apos;)        advance();    else        error();}void E1(){    if (sym == &apos;,&apos;)    {        advance();        F();        E1();    }    else if (isIn(sym, FOLLOW_E1, sizeof(FOLLOW_E1)/sizeof(FOLLOW_E1[0])))        ;    else        error();}void E(){    F();    E1();}void C1(){    if (isIn(sym, FIRST_L, sizeof(FIRST_L)/sizeof(FIRST_L[0])))    {        L();        if (sym == &apos;}&apos;)            advance();        else            error();    }    else if (sym == &apos;}&apos;)        advance();    else        error();}void C(){    if (sym == &apos;{&apos;)    {        advance();        C1();    }    else if (sym == &apos;,&apos;)    {        advance();        D();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else if (sym == &apos;;&apos;)        advance();    else        error();}void B(){    J();    G();    C();}void A1(){    if (isIn(sym, FIRST_B, sizeof(FIRST_B)/sizeof(FIRST_B[0])))    {        B();        A1();    }    else if (isIn(sym, FOLLOW_A1, sizeof(FOLLOW_A1)/sizeof(FOLLOW_A1[0])))        ;    else        error();}void A(){    B();    A1();}void M(){    if (sym == &apos;;&apos;)        advance();    else if (isIn(sym, FIRST_N, sizeof(FIRST_N)/sizeof(FIRST_N[0])))    {        N();        if (sym == &apos;;&apos;)            advance();        else            error();    }    else        error();}void N(){    O();}void O(){    P();    O1();}void O1(){    if (sym == &apos;k&apos;)    {        advance();        P();        O1();    }    else if (isIn(sym, FOLLOW_O1, sizeof(FOLLOW_O1)/sizeof(FOLLOW_O1[0])))        ;    else        error();}void P(){    Q();    P2();}void P1(){    if (sym == &apos;+&apos;)    {        advance();        Q();    }    else if (sym == &apos;-&apos;)    {        advance();        Q();    }    else        error();}void P2(){    if (isIn(sym, FIRST_P1, sizeof(FIRST_P1)/sizeof(FIRST_P1[0])))    {        P1();        P2();    }    else if (isIn(sym, FOLLOW_P2, sizeof(FOLLOW_P2)/sizeof(FOLLOW_P2[0])))        ;    else        error;}void Q(){    if (isIn(sym, FIRST_R, sizeof(FIRST_R) / sizeof(FIRST_R[0])))    {        R();        Q2();    }    else if (sym == &apos;-&apos;)    {        advance();        R();        Q2();    }    else        error();}void Q1(){    if (sym == &apos;*&apos;)    {        advance();        R();    }    else if (sym == &apos;/&apos;)    {        advance();        R();    }    else if (sym == &apos;%&apos;)    {        advance();        R();    }    else        error();}void Q2(){    if (isIn(sym, FIRST_Q1, sizeof(FIRST_Q1) / sizeof(FIRST_Q1[0])))    {        Q1();        Q2();    }    else if (isIn(sym, FOLLOW_Q2, sizeof(FOLLOW_Q2) / sizeof(FOLLOW_Q2[0])))        ;    else        error();}void R(){    if (sym == &apos;i&apos;)    {        advance();        R1();    }    else if (sym == &apos;(&apos;)    {        advance();        N();    }    else if (sym == &apos;n&apos;)        advance();    else if (sym == &apos;s&apos;)        advance();    else        error();}void R1(){    if (sym == &apos;(&apos;)    {        advance();        R2();    }    else if (sym == &apos;l&apos;)        advance();    else if (sym == &apos;=&apos;)    {        advance();        N();    }    else if (sym == &apos;[&apos;)    {        advance();        N();        if (sym == &apos;]&apos;)            advance();        else            error();        R3();    }    else if (isIn(sym, FOLLOW_R1, sizeof(FOLLOW_R1) / sizeof(FOLLOW_R1[0])))        ;    else        error();}void R2(){    if (isIn(sym, FIRST_S, sizeof(FIRST_S) / sizeof(FIRST_S[0])))    {        S();        if (sym == &apos;)&apos;)            advance();        else            error();    }    else if (sym == &apos;)&apos;)        advance();    else        error();}void R3(){    if (sym == &apos;=&apos;)    {        advance();        N();    }    else if (isIn(sym, FOLLOW_R3, sizeof(FOLLOW_R3) / sizeof(FOLLOW_R3[0])))        ;    else        error();}void S(){    N();    S1();}void S1(){    if (sym == &apos;,&apos;)    {        advance();        N();        S1();    }    else if (isIn(sym, FOLLOW_S1, sizeof(FOLLOW_S1) / sizeof(FOLLOW_S1[0])))        ;    else        error();}void T(){    if (sym == &apos;i&apos;)    {        advance();        T1();    }    else        error;}void T1(){    if (sym == &apos;,&apos;)    {        advance();        if (sym == &apos;i&apos;)            advance();        else            error();        T1();    }    else if (isIn(sym, FOLLOW_T1, sizeof(FOLLOW_T1) / sizeof(FOLLOW_T1[0])))        ;    else        error();}int main(){    char* symbolList[6200];    symbolList[0] = &apos;\0&apos;;    result[0] = &apos;\0&apos;;    //char fileName[40];    char* symbol[20];    symbol[0] = &apos;\0&apos;;    //printf(&quot;请输入源文件路径(不超过40个字符)：&quot;);    //scanf(&quot;%s&quot;, &amp;fileName);    char* fileName = &quot;F:\\编译技术实验\\实验2\\test.c&quot;;    strcat(result, tokenise(symbolList, symbol, fileName));    advance();    A();    if (sym != &apos;#&apos;)        error();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase基本操作</title>
      <link href="/2020/02/13/HBase-basic-operations/"/>
      <url>/2020/02/13/HBase-basic-operations/</url>
      
        <content type="html"><![CDATA[<h3 id="HBase-shell的使用"><a href="#HBase-shell的使用" class="headerlink" title="HBase shell的使用"></a>HBase shell的使用</h3><p>HBase自带的shell是用JRuby（Java写的Ruby解释器）写的命令行的工具，是用ruby语言实现的，其shell脚本也是ruby实现的。<br>执行以下命令进入HBase的shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>HBASE_HOME/bin/hbase shell</span><br></pre></td></tr></table></figure><h4 id="用create命令建表c"><a href="#用create命令建表c" class="headerlink" title="用create命令建表c"></a>用create命令建表c</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create '表名', '列族名'</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 row(s) in 操作时间</span><br></pre></td></tr></table></figure><ul><li>HBase的表都是由列族（Column Family）组成的</li><li>没有列族的表是没有意义的</li><li>列并不是依附于表上，而是依附于列族上</li></ul><p>不定义列的原因：<br>HBase中的列全部都是灵活的，可以随便定义。在插入数据时其实是向HBase中插入一个单元格，这个单元格是由表：列族：行：列来定位的，所以应该说由于这个单元格有一个列属性A，才让这行数据有了一个A列。<br>表属性定义的位置：列族</p><h4 id="用list命令来查看库中有哪些表"><a href="#用list命令来查看库中有哪些表" class="headerlink" title="用list命令来查看库中有哪些表"></a>用list命令来查看库中有哪些表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TABLE                                                   </span><br><span class="line">表名                                                    </span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0809 seconds                                            </span><br><span class="line">=&gt; ["表名"]</span><br></pre></td></tr></table></figure><h4 id="用describe命令来查看表属性"><a href="#用describe命令来查看表属性" class="headerlink" title="用describe命令来查看表属性"></a>用describe命令来查看表属性</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe 'test'</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Table 表名 is ENABLED                                           </span><br><span class="line">表名                                                </span><br><span class="line">COLUMN FAMILIES DESCRIPTION                                        </span><br><span class="line">&#123;NAME =&gt; 'cf', VERSIONS =&gt; '1', EVICT_BLOCKS_ON_CLOSE =&gt; 'false', NEW_VERSION_BEHAVIOR =&gt; 'false', KEEP_DEL</span><br><span class="line">ETED_CELLS =&gt; 'FALSE', CACHE_DATA_ON_WRITE =&gt; 'false', DATA_BLOCK_ENCODING =&gt; 'NONE', TTL =&gt; 'FOREVER', MIN</span><br><span class="line">_VERSIONS =&gt; '0', REPLICATION_SCOPE =&gt; '0', BLOOMFILTER =&gt; 'ROW', CACHE_INDEX_ON_WRITE =&gt; 'false', IN_MEMOR</span><br><span class="line">Y =&gt; 'false', CACHE_BLOOMS_ON_WRITE =&gt; 'false', PREFETCH_BLOCKS_ON_OPEN =&gt; 'false', COMPRESSION =&gt; 'NONE', </span><br><span class="line">BLOCKCACHE =&gt; 'true', BLOCKSIZE =&gt; '65536'&#125;</span><br><span class="line"></span><br><span class="line">1 row(s)</span><br><span class="line"></span><br><span class="line">QUOTAS                                                  </span><br><span class="line">0 row(s)</span><br><span class="line">Took 0.2439 seconds</span><br></pre></td></tr></table></figure><p>NAME属性是列族的而不是表的，HBase表上只有少数的几个属性，大部分属性都在列族上。<br>新增列族（shell中并无直接的命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter  '表名','列族名'</span><br></pre></td></tr></table></figure><p>对列族的所有操作都会同步到所有拥有这个表的RegionServer上，可以看到总共有多少个RegionServer，当前执行了几个。当有很多客户端连着的时候直接新增列族对性能的影响较大。</p><h4 id="用put命令来插入数据"><a href="#用put命令来插入数据" class="headerlink" title="用put命令来插入数据"></a>用put命令来插入数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put '表名','行键名','列族：列名','数据值'</span><br></pre></td></tr></table></figure><h4 id="scan命令获取表数据"><a href="#scan命令获取表数据" class="headerlink" title="scan命令获取表数据"></a>scan命令获取表数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan '表名'，&#123;STARTROW=&gt;'行键'，ENDROW=&gt;'行键'&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROW             COLUMN+CELL                                  </span><br><span class="line">行键            column=列族名:列名, timestamp=1575285791187, value=值              </span><br><span class="line">n row(s)</span><br><span class="line">Took 0.0059 seconds</span><br></pre></td></tr></table></figure><p>关于时间戳：每个单元格都可以存储多个版本（version）的值，但是是用timestamp时间戳来当版本号使用。若put语句不指定时间戳则系统自动用当前时间来指定。时间戳可以指定为任意数字，scan时会显示最大（最新）的时间戳版本的值。<br>修改表的版本数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter 'test',&#123;NAME=&gt;'列族名',VERSION=&gt;版本数&#125;</span><br></pre></td></tr></table></figure><p>get命令查询某单元格数据(当表的数据很大时，get查询比scan快很多）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get '表名' ,'行键',&#123;COLUMN=&gt;'列族名：列名', VERSIONS=&gt;想看到的版本数&#125;</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete '表名','行键','列族：列'</span><br></pre></td></tr></table></figure><p>删除指定版本的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete '表名','行键','列族：列',时间戳</span><br></pre></td></tr></table></figure><p>HBase删除记录并不是真的删除了数据，而是放置了一个墓碑标记（tombstone marker），将数据标记为不可见，这是为了提升性能，这样HBase可以定期清理被删的数据，定期指的是自动合并（compaction）时。<br>使得被打上墓碑标记的数据也能被查询到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan 'test',&#123;RAW=&gt;true,VERSIONS=&gt;5&#125;</span><br></pre></td></tr></table></figure><p>deleteall删除整行记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteall '表名','行键'</span><br></pre></td></tr></table></figure><h4 id="用disable来停用表"><a href="#用disable来停用表" class="headerlink" title="用disable来停用表"></a>用disable来停用表</h4><p>使用HBase时是不能随便删除表的，如果很多客户端正在连接，或者有HBase正在做合并或者分裂操作，如果删除了表会造成无法恢复的错误，因此HBase不允许直接删除表，先进行disable停表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable '表名'</span><br></pre></td></tr></table></figure><h4 id="drop删除表"><a href="#drop删除表" class="headerlink" title="drop删除表"></a>drop删除表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop '表名'</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 时空大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么Java的System.int/out/err值为null？</title>
      <link href="/2020/02/13/System-null/"/>
      <url>/2020/02/13/System-null/</url>
      
        <content type="html"><![CDATA[<p>例：<br>System源码中这样写：</p><p>​    public final static PrintStream out = null;</p><p>System.out是PrintStream类型的变量，引用的是null，还被final修饰为不可更改，为什么在调用PrintStream中的println()方法时没有报错呢？<br>实际上在System类的开头有静态代码块：</p><p>​    static {<br>​        registerNatives()；<br>​    }</p><p>在加载System类的时候先调用了System类中的静态方法registerNatives()，<br>它在虚拟机里注册System需要使用的一些本地代码，<br>在System类中这样定义registerNatives()方法：</p><p>​    private static native void registerNatives()；</p><p>也使用了native修饰符,这意味着该方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。<br>Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。<br>它会告诉虚拟机到哪些文件中找到相应的实现。In，out，err先初始化为null（防止编译器内联访问它们），然后由initializeSystemClass()方法类使用setInt0，setOut0，setErr0把实际连接到输入输出设备的句柄传给虚拟机并赋值给in，out，err。<br>因此System类是首先声明了in/out(实际上还有err)静态成员常量,然后在registerNatives()中对其进行赋值，使得能够调用println等方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase Meta表与Root表</title>
      <link href="/2020/02/08/HBase-Meta-Root/"/>
      <url>/2020/02/08/HBase-Meta-Root/</url>
      
        <content type="html"><![CDATA[<p><strong>Meta表的作用</strong></p><p>记录的信息：</p><ol><li>数据的Rowkey在哪个Region的范围</li><li>Region在哪个RegionServer上</li></ol><p>（Region是HBase中分布式存储和负载均衡的最小单元）</p><p><strong>Meta表的Rowkey</strong></p><p>region所在的表名+region的StartKey+时间戳</p><p>这三者的MD5值也是HBase在HDFS上存储的region名字</p><p><strong>Meta表的列族和列</strong></p><p>表中最主要的Family：info</p><p>info里包含三个Column：regioninfo，server，serverstartcode</p><p>regioninfo就是region的详细信息，包括Startkey、Endkey以及每个Family的信息等。</p><p>server存储的是管理该region的RegionServer地址</p><p>因此当Region被拆分、合并或者重新分配的时候都需要修改这张表的内容。</p><p><strong>Region的定位</strong></p><p>如果是第一次读取：</p><ol><li>读取zookeeper中root表的位置</li><li>从root表中读取包含所需用户表的meta表的位置</li><li>读取Meta表中用户表的位置</li><li>读取数据</li></ol><p>如果已经读取过一次，则root表和Meta表都会缓存到本地，直接去用户表的位置读取数据</p><p>Client端在访问数据的过程中并没有涉及到Master节点，也就是说HBase日常的数据操作并不需要Master，不会造成Master的负担。</p><p>从存储结构和操作方法的角度来说，-ROOT-、.META.与其他表没有任何区别。它们与众不同的地方是HBase用它们来存贮一个重要的系统信息：</p><ul><li>-ROOT-：记录.META.表的Region信息。</li><li>.META.：记录用户表的Region信息。</li></ul><p>其中-ROOT-表本身只会有一个region，这样保证了只需要三次跳转，就能定位到任意region</p>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 时空大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯TEG云架构后台开发实习面经</title>
      <link href="/2020/02/02/Tencent-Interview/"/>
      <url>/2020/02/02/Tencent-Interview/</url>
      
        <content type="html"><![CDATA[<p>offer: 后台开发实习工程师，在TEG云架构平台组负责NoSQL存储平台的研发，base深圳。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li><p>自我介绍</p></li><li><p>问项目：</p><ul><li>旅游大数据项目：<ul><li>项目内容以及自己负责的部分</li><li>为什么采用HBase存储数据</li><li>在项目中对比过HBase和MySQL的性能表现吗</li><li>基于HBase的时空数据索引是怎么设计的</li><li>数据获取方式</li><li>数据都存了哪些字段</li><li>了解MySQL吗</li></ul></li><li>区块链项目：<ul><li>项目内容以及自己负责的部分</li><li>怎么实现区块的互连</li><li>Merkle树构建方式</li><li>集群通信怎么实现</li><li>怎么实现一个节点向所有节点发消息</li><li>数据怎么存储</li></ul></li></ul></li><li><p>计网：</p><ul><li>三次握手</li><li>四次分手</li></ul></li><li><p>编程语言：</p><ul><li>会不会C/C++</li><li>Java的HashMap和HashTable的区别</li><li>Java实现线程安全的机制</li></ul></li><li><p>操作系统：</p><ul><li>Linux查看CPU/内存占用情况的命令</li><li>Linux查看端口占用情况的命令</li><li>Linux查看磁盘存储情况的命令</li><li>……</li></ul></li><li><p>设计模式了解吗（不了解）</p></li><li><p>数据结构与算法</p><ul><li>都熟悉哪些数据结构</li><li>熟悉优先队列吗</li><li>腾讯在线文档手写快排</li><li>简述快排的思想</li><li>快排和分治法的对比</li><li>阐述快排的时间复杂度</li></ul></li><li><p>其他：</p><ul><li>从什么时候开始学自己的这套技术栈</li><li>学校教了哪些课程</li><li>平时逛哪些网站</li><li>有什么问题要问他的（我问了他负责的部门，对我的建议，对我面试的评价）：<ul><li>面试官在TEG云架构组做海量数据存储，总体评价良好，建议多学习C++、数据结构和操作系统</li></ul></li></ul></li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li>目前的学业情况以及将来的安排</li><li>自己从什么时候开始有意识学习自己的技术体系</li><li>学习过程中都看了哪些书籍</li><li>除Java外还会什么编程语言</li><li>C的结构体对齐</li><li>协程</li><li>项目中在后端开发方面做了什么工作</li><li>Spring和SpringBoot的区别</li><li>在项目中怎么对接后端和前端</li><li>HBase数据备份几份</li><li>HBase备份的数据出错该怎么恢复</li><li>HDFS怎么实现删除</li><li>谈一下学习过程中对你影响最大的人</li><li>对他有什么想问的（心里感觉凉透，贼不要脸的问了后面还有面试吗，面试官居然淡定说等HR再问你点后续问题吧……）</li></ol><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ol><li>将来的规划</li><li>对工作的理解</li><li>老家在哪</li></ol><h3 id="前期自己准备的考点"><a href="#前期自己准备的考点" class="headerlink" title="前期自己准备的考点"></a>前期自己准备的考点</h3><ol><li><p>旅游大数据项目：</p><ul><li>客流统计阐述（如何使用HBase）</li><li>舆情分析阐述</li></ul></li><li><p>区块链项目：</p><ul><li>公有链、联盟链、私有链阐述</li><li>SHA-256等各种加密算法</li><li>Merkle树</li><li>WebSocket协议</li><li>P2P</li><li>PBFT算法</li></ul></li><li><p>HBase数据库与大数据：</p><ul><li>HBase全分布搭建流程</li><li>HBase内存配置优化</li><li>Hadoop架构</li><li>Hadoop高可用</li><li>HBase索引算法（各种树）</li><li>Z曲线</li><li>GeoHash（Base32编码)</li><li>读写阻塞</li><li>朱丽叶暂停</li><li>NTP/crond</li><li>HBase架构                                  </li><li>LSM树</li><li>B+树</li><li>WAL</li><li>读机制</li><li>写机制</li><li>BlockCache缓存</li><li>Region拆分与合并</li><li>HFile合并</li><li>Zookeeper架构与机制</li><li>MapReduce原理和代码</li></ul></li><li><p>Java:</p><ul><li>Java多线程通信机制</li><li>进程间通信</li><li>线程池</li><li>Java线程安全</li><li>Java集合继承关系</li><li>HashMap</li><li>HashTable</li><li>HashTree</li></ul></li><li><p>操作系统：</p><ul><li>进程线程区别</li><li>Linux内核线程</li><li>进程同步</li><li>线程同步</li><li>死锁</li><li>进程状态</li><li>线程状态</li><li>进程调度策略</li><li>分页和分段</li><li>页面置换算法</li><li>虚拟内存</li><li>颠簸</li><li>局部性原理</li><li>常用Linux命令</li></ul></li><li><p>Java后端：</p><ul><li>SSM</li><li>Spring完整交互流程</li><li>IOC</li><li>Linux服务器上部署Java后端</li><li>AOP</li></ul></li><li><p>计网：</p><ul><li>三次握手</li><li>四次分手</li><li>常考报文内容</li><li>Http与Https</li><li>DNS</li><li>拥塞控制</li><li>阻塞I/O网络编程</li><li>非阻塞I/O网络编程</li><li>select网络编程</li></ul></li><li><p>数据结构：</p><ul><li>二分查找</li><li>基本排序</li><li>快排、归并、堆排</li><li>二叉树</li><li>算法时空分析</li><li>分治法</li><li>图遍历</li><li>字符串算法</li><li>各种进制转换及编码实现</li></ul></li><li><p>JVM：</p><ul><li>Java运行时数据区域</li><li>程序计数器</li><li>JVM栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li><li>运行时常量池</li><li>直接内存</li><li>垃圾回收</li><li>判断对象是否可回收</li><li>引用类型</li><li>GC算法</li><li>垃圾回收器</li><li>内存分配与回收策略</li><li>Minor GC与Full GC</li><li>内存分配策略</li><li>Full GC触发条件</li><li>类加载机制</li><li>类生命周期类加载过程</li><li>类初始化时机</li><li>类与类加载器</li><li>类加载器分类</li><li>双亲委派模型</li><li>自定义类加载器实现</li></ul></li></ol><p>写在最后： </p><p>能收获鹅厂offer是我不敢奢求的结果，一个月前才开始准备，很多东西都是临时东拼西凑学来的。由于前半学期疲于考雅思（还没通过），我比周围的小伙伴准备的都晚，又赶上期末考试周，看着别人愉快的收获offer，生活和心理上都充满了极大的压力。真正的勇士，是知其不可而为之，最后的结果如何，不拼怎么知道。准备实习是一场遇强则强的战斗，越是发现自己有缺点，越是尽力去弥补，然后会发现更多的缺点，抓住每一个能完善的机会，直到面试开始的前一秒都不要放弃。非常感谢周围帮助过、鼓励过我的人，是他们一次次把我从崩溃的边缘拉回。这份面经送给未来准备实习的朋友做参考，相信你们一定可以成功。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> 时空大数据 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面经 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Java后端 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析器</title>
      <link href="/2019/11/19/lexical-Analysis/"/>
      <url>/2019/11/19/lexical-Analysis/</url>
      
        <content type="html"><![CDATA[<p>自己写的Java词法分析器：</p><pre><code>/*Author: Justin Han* Time: 2019/11/19*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;//定义字符类别号#define ALPHABET 0#define DEGIT 1#define WHITESPACE 2#define SEPCHAR 3#define MATHCHAR 4#define STRING 5//定义字符类别内容const char alphabet[52] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos; };const char degit[10] = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos; };const char whitespace[3] = { &apos; &apos;, &apos;\n&apos;, &apos;\t&apos; };const char sepchar[10] = { &apos;{&apos;, &apos;}&apos;, &apos;;&apos;, &apos;,&apos;, &apos;.&apos;, &apos;(&apos;, &apos;)&apos; ,&apos;&quot;&apos;, &apos;[&apos;, &apos;]&apos;};const char mathchar[9] = { &apos;&gt;&apos;, &apos;&lt;&apos;, &apos;=&apos;, &apos;+&apos;, &apos;-&apos;, &apos;|&apos;, &apos;/&apos;, &apos;*&apos;, &apos;&amp;&apos;};/*定义词类别号* 整数 19* 浮点数 20* 字符串常量 21* 特殊符号 sepchar数组下标+30* 运算符号 mathchar数组下标+40* 标识符 22* 注释 23*/const char* tokens[19] = { &quot;args&quot;, &quot;class&quot;, &quot;else&quot;, &quot;for&quot;, &quot;if&quot;, &quot;int&quot;, &quot;main&quot;, &quot;new&quot;, &quot;out&quot;, &quot;package&quot;, &quot;private&quot;, &quot;public&quot;, &quot;print&quot;, &quot;println&quot;, &quot;return&quot;, &quot;static&quot;, &quot;String&quot;, &quot;System&quot;, &quot;void&quot; };const char* mathWords[17] = { &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;=&quot;, &quot;+&quot;, &quot;-&quot;, &quot;|&quot;, &quot;/&quot;, &quot;*&quot;, &quot;&amp;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;++&quot;, &quot;--&quot;, &quot;==&quot; ,&quot;||&quot;, &quot;-=&quot;, &quot;+=&quot;};//字符转字符串函数char* toString(char ch){    char str[2];    str[0] = ch;    str[1] = 0;    return str;}//生成单词符号char* token(char* symbol, int charClass){    char str[30] = &quot;(&quot;;    if (charClass == 0)    {        for (int i = 0; i &lt; 19; i++)        {            if (strcmp(symbol, tokens[i]) == 0)            {                char buff[4];                strcat(str, symbol);                strcat(str, &quot;, &quot;);                sprintf(buff, &quot;%d&quot;, i);                strcat(str, buff);                strcat(str, &quot;)\n&quot;);                return str;            }        }        strcat(str, symbol);        strcat(str, &quot;, 22&quot;);        strcat(str, &quot;)\n&quot;);        return str;    }    else if (charClass == 11)    {        strcat(str, symbol);        strcat(str, &quot;, 19&quot;);        strcat(str, &quot;)\n&quot;);        return str;    }    else if (charClass == 12)    {        strcat(str, symbol);        strcat(str, &quot;, 20&quot;);        strcat(str, &quot;)\n&quot;);        return str;    }    else if (charClass == 3)    {        for (int i = 0; i &lt; 10; i++)        {            if (strcmp(symbol, toString(sepchar[i])) == 0)            {                char buff[4];                strcat(str, symbol);                strcat(str, &quot;, &quot;);                sprintf(buff, &quot;%d&quot;, i+30);                strcat(str, buff);                strcat(str, &quot;)\n&quot;);                return str;            }        }    }    else if (charClass == 4)    {        for (int i = 0; i &lt; 17; i++)        {            if (strcmp(symbol, mathWords[i]) == 0)            {                char buff[4];                strcat(str, symbol);                strcat(str, &quot;, &quot;);                sprintf(buff, &quot;%d&quot;, i + 40);                strcat(str, buff);                strcat(str, &quot;)\n&quot;);                return str;            }        }    }    else if (charClass == 5)    {        strcat(str, &quot;\&quot;&quot;);        strcat(str, symbol);        strcat(str, &quot;\&quot;, 21&quot;);        strcat(str, &quot;)\n&quot;);        return str;    }    else    {        strcat(str, symbol);        strcat(str, &quot;, 23&quot;);        strcat(str, &quot;)\n&quot;);        return str;    }}// 判断字符类别函数int type(char ch){    for (int i = 0; i &lt; 52; i++)    {        if (ch == alphabet[i])            return ALPHABET;    }    for (int i = 0; i &lt; 10; i++)    {        if (ch==degit[i])            return DEGIT;    }    for (int i = 0; i &lt; 3; i++)    {        if (ch== whitespace[i])            return WHITESPACE;    }    for (int i = 0; i &lt; 10; i++)    {        if (ch== sepchar[i])        {            if (ch == &apos;&quot;&apos;) {                return STRING;            }            else                return SEPCHAR;        }    }    for (int i = 0; i &lt; 9; i++)    {        if (ch== mathchar[i])            return MATHCHAR;    }}char* tokenise(char* symbolList, char* symbol, char* fileName){    FILE* fp;    char ch;    //如果没有找到文件，给出提升并退出    if ((fp = fopen(fileName, &quot;rt&quot;)) == NULL)    {        printf(&quot;没有找到文件，按任意键退出&quot;);        getch();        exit(1);    }    ch = fgetc(fp);    while (ch != EOF)    {        switch (type(ch))        {            case WHITESPACE:                ch = fgetc(fp);                break;            case ALPHABET:                strcat(symbol, toString(ch));                ch = fgetc(fp);                while (type(ch) == 0 || type(ch) == 1)                {                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                }                strcat(symbolList, token(symbol, ALPHABET));                symbol[0] = &apos;\0&apos;;                break;            case DEGIT:                strcat(symbol, toString(ch));                ch = fgetc(fp);                int isFloat = 11;                while (type(ch)==1)                {                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                }                if (ch== &apos;.&apos;)                {                    isFloat = 12;                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                    while (type(ch) == 1)                    {                        strcat(symbol, toString(ch));                        ch = fgetc(fp);                    }                }                strcat(symbolList, token(symbol, isFloat));                symbol[0] = &apos;\0&apos;;                break;            case MATHCHAR:                strcat(symbol, toString(ch));                ch = fgetc(fp);                if (type(ch) == 4)                {                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                }                if (strcmp(symbol, &quot;//&quot;) == 0)                    strcat(symbolList, token(symbol, 23));                else                    strcat(symbolList, token(symbol, MATHCHAR));                symbol[0] = &apos;\0&apos;;                break;            case SEPCHAR:                strcat(symbol, toString(ch));                ch = fgetc(fp);                strcat(symbolList, token(symbol, SEPCHAR));                symbol[0] = &apos;\0&apos;;                break;            case STRING:                ch = fgetc(fp);                while (ch != &apos;&quot;&apos;)                {                    strcat(symbol, toString(ch));                    ch = fgetc(fp);                }                strcat(symbolList, token(symbol, STRING));                ch = fgetc(fp);                symbol[0] = &apos;\0&apos;;                break;            default:                printf(&quot;ERROR: Unknown Char: %c\n&quot;, ch);                ch = fgetc(fp);                break;        }    }    fclose(fp);    int i = strlen(symbolList);    return symbolList;}void writeFile(char* string, char* fileName){    FILE* fp;    fp = fopen(fileName, &quot;w&quot;);    fputs(string, fp);    fclose(fp);    return;}int main(){    char* symbolList[6200];    char result[6200];    result[0] = &apos;\0&apos;;    symbolList[0] = &apos;\0&apos;;    //char* fileName = &quot;F:\\编译技术实验\\实验1\\sample.txt&quot;;    char fileName[40];    char resultName[40];    char* symbol[20];    symbol[0] = &apos;\0&apos;;    printf(&quot;请输入源文件路径(不超过40个字符)：&quot;);    scanf(&quot;%s&quot;, &amp;fileName);    strcat(result, tokenise(symbolList, symbol, fileName));    printf(&quot;请输入结果文件路径(不超过40个字符)：&quot;);    scanf(&quot;%s&quot;, &amp;resultName);    writeFile(result, resultName);    printf(&quot;%s&quot;, result);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术第一章</title>
      <link href="/2019/11/16/java1/"/>
      <url>/2019/11/16/java1/</url>
      
        <content type="html"><![CDATA[<p>Java“白皮书”关键术语</p><p>简单性：</p><ul><li>Java语法是C++语法的一个“纯净版本“：没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等</li></ul><p>面向对象：</p><ul><li>Java的面向对象特性与C++相当</li><li>Java中的多重继承采用相对于C++更简单的接口概念</li><li>Java提供了比C++更丰富的运行时自省功能</li></ul><p>分布式：</p><ul><li>Java有丰富的例程库， 用于处理像HTTP和FTP之类的TCP/IP协议</li></ul><p>健壮性：</p><ul><li>此方面Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性</li><li>Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题</li></ul><p>安全性：</p><ul><li>Java适用于网络/分布式环境，因此在安全性投入很大精力</li><li>能够防范运行时堆栈溢出。如蠕虫、病毒常用的攻击手段</li><li>能够防范破坏自己的进程空间之外的内存</li><li>能够防范未经授权读写文件</li></ul><p>体系结构中立：</p><ul><li>Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现生成一个体系结构中立的目标文件格式从而使得编译后的代码可以很容易在任何机器上解释执行</li><li>Java虚拟机的一些优点：<ul><li>虽弱解释虚拟机指令肯定会比全速运行机器指令慢很多，但是虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程成为即时编译</li><li>可以检测指令序列的行为，从而增强安全性</li></ul></li></ul><p>可移植性：</p><ul><li>Java规范中没有”依赖具体实现“的地方，基本数据类型的大小以及有关运算都做了明确说明</li><li>Java中数据类型具有固定的大小，比如int永远为32位整数</li><li>二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰</li><li>字符串用标准的Unicode格式存储</li></ul><p>解释型：</p><p> <strong>Java</strong>首先由编译器编译成.class（字节码）文件，然后在通过JVM从.class文件中读一行<strong>解释</strong>执行一行，所以它<strong>是解释型</strong>的<strong>语言</strong>。 Java开发环境并没有将重点放在“尝试后能立即看到结果”这种体验上。</p><p>高性能：</p><p>字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定 CPU 的机器码。Java即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”），即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p><p>多线程：</p><p>多线程可以带来更好的交互响应和实时行为。</p><p>动态性：</p><p> 动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等 。Java虽然属于静态语言，但是比C&amp;C++拥有更好的动态性。库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。在 Java 中找出运行时类型信息十分简单。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python脚本自动使用labelme标注数据集</title>
      <link href="/2019/11/06/labelme-python/"/>
      <url>/2019/11/06/labelme-python/</url>
      
        <content type="html"><![CDATA[<h3 id="使用工具：labelme（标注mask数据集用的）"><a href="#使用工具：labelme（标注mask数据集用的）" class="headerlink" title="使用工具：labelme（标注mask数据集用的）"></a>使用工具：labelme（标注mask数据集用的）</h3><p>GitHub地址： <a href="https://github.com/wkentaro/labelme" target="_blank" rel="noopener">https://github.com/wkentaro/labelme</a><br><strong>windows：</strong><br>python2</p><pre><code>pip install pyqt</code></pre><p>​    pip install labelme</p><p>python3</p><p>​    pip install pyqt5<br>​    pip install labelme</p><p><strong>Ubuntu16.04系统下采用自带的python2.7环境：</strong></p><pre><code>sudo apt-get install python-qt4 pyqt4-dev-tools </code></pre><p>​    sudo pip install labelme  <em># python2 works</em></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在终端中进入labelme.exe所在文件夹，执行命令：</p><p>​    labelme</p><p>出现界面后，点击open， 打开需要标注的图像，选择对目标区域进行标注<br>标注完后点击会产生json文件</p><h3 id="python自动图像语义分割标注脚本："><a href="#python自动图像语义分割标注脚本：" class="headerlink" title="python自动图像语义分割标注脚本："></a>python自动图像语义分割标注脚本：</h3><p>引入os库实现python在命令行中执行命令：</p><p>​    import os</p><p>定义获取之前制作的全部json文件的文件名的函数</p><pre><code>def getAllJson(path):    &quot;&quot;&quot;获取所有json文件名\n    path : 文件夹路径字符串&quot;&quot;&quot;    dirs = os.listdir(path)    dirList = []    for d in dirs :        if os.path.splitext(d)[1] == &quot;.json&quot; :            dirList.append(d)    return dirList</code></pre><p>定义生成语义分割文件的函数，命令行中的命令格式为”labelme_json_to_dataset 文件名“：</p><p>​    def generate(fileList) :<br>        “””生成数据集图像\n<br>        list : 文件名列表”””<br>        for f in fileList :<br>            s = “labelme_json_to_dataset “ + “F:/ISIC/ISIC-images/json/“ + f<br>            os.system(s)</p><p>执行函数：</p><pre><code>fileList = getAllJson(&quot;F:/ISIC/ISIC-images/json&quot;)generate(fileList)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K摇臂赌博机</title>
      <link href="/2019/11/04/Reinforcement-learning/"/>
      <url>/2019/11/04/Reinforcement-learning/</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>探索与利用</strong></p><p><strong>强化学习与监督学习的不同：</strong></p><p>没有训练数据告诉机器应当做哪个动作，需通过尝试得出各个动作产生的结果，从而得到最终奖赏。</p><p><strong>最大化单步奖赏：</strong></p><ul><li>需要知道每个动作带来的奖赏</li><li>执行奖赏最大的动作</li></ul><p><strong>算法背景：</strong></p><p>一般情况下，每个单步动作的奖赏值来自于一个概率分布，仅通过一次尝试不能确切地获得平均奖赏值。因此，单步强化学习任务对应了一个理论模型——K-摇臂赌博机。K-摇臂赌博机有K个摇臂，赌徒在投入一个硬币后可选择按下其中一个摇臂， 每个摇臂以一定的概率吐出硬币，但这个概率赌徒并不知道。赌徒的目标是通过一定的策略最大化自己的奖赏，即获得最多的硬币。</p><p><strong>仅探索法：</strong></p><p>若仅为获知每个摇臂的期望奖赏，则可将所有的尝试机会平均分配给每个摇臂（即轮流按下每个摇臂），最后以每个摇臂各自的平均吐币概率作为其奖赏期望的近似估计。仅探索法能很好的估计每个摇臂的奖赏，却会失去很多选择最优摇臂的机会。</p><p><strong>仅利用法：</strong></p><p>若仅为执行奖赏最大的动作，则可按下目前最优的（即到目前为止平均奖赏最大的）摇臂，若有多个摇臂同为最优，则从中随机选取一个。仅利用法没有很好的估计摇臂期望奖赏，很可能经常选不到最优摇臂。仅利用与仅探索这两种方法都难以使最终的累积奖赏最大化。</p><p><strong>探索-利用窘境：</strong></p><p>由于尝试次数有限，探索和利用是矛盾的，加强一方则会削弱另一方。欲累积奖赏最大，则必须在探索与利用之间达成较好的折中。</p></li><li><p><strong>ε -贪心</strong></p><p>基于概率来对探索和利用折中：每次尝试以ε的概率进行探索，即以均匀概率随机选取一个摇臂；即选择当前平均奖赏最高的摇臂（若有多个则随机选取）以1-ε的概率进行利用。</p><p>令Q(k)记录摇臂k的平均奖赏。若摇臂k被尝试了n次，得到的奖赏为vi，则平均奖赏为</p><p><img src="https://github.com/HanJiaxing521/HanJiaxing521.github.io/raw/master/img/qhxx-1.png" alt=""></p><p><img src="https://github.com/HanJiaxing521/HanJiaxing521.github.io/raw/master/img/qhxx-2.png" alt=""></p><p>可见无论摇臂被尝试多少次都仅需记录两个值：已尝试次数n-1和最近平均奖赏Qn-1(k)。</p><p>ε-贪心算法如下：</p><p>输入：摇臂数K；</p><p>​            奖赏函数R；</p><p>​            尝试次数T；</p><p>​             探索概率ε</p><p>过程：</p><p>r=0；</p><p>任意i=1，2，……K：Q(i)=0， count(i) = 0;</p><p>for t = 1,2,……,T do</p><p>​    if rand()&lt;ε then</p><p>​        k = 从1，2，……K中以均匀分布随机选取</p><p>​    else</p><p>​        k=argmaxiQ(i)</p><p>​    end if</p><p>​    v = R(k);</p><p>​    r = r+v;</p><p>​    Q(k) = (Q(k)*count(k)+v)/count(k)+1;</p><p>​    count(k) = count(k)+1;</p><p>end for</p><p>输出：累积奖赏r</p><p>由于摇臂奖赏的不确定性较大，则概率分布较宽时需要更大的ε值，分布较集中时需要较小的ε值，一段时间后需要尝试的次数逐渐减少，可令ε=1/(t^(1/2))</p></li><li><p><strong>Softmax算法</strong></p><p>Softmax算法基于当前已知的摇臂平均奖赏来对探索和利用进行折中。若某些摇臂的平均奖赏明显高于其他摇臂，则它们被选取的概率也明显更高。</p><p>Softmax算法中摇臂概率的分配基于Boltzmann分布：</p><p><img src="https://github.com/HanJiaxing521/HanJiaxing521.github.io/raw/master/img/qhxx-3.png" alt=""></p><p>Q(i)记录当前摇臂的平均奖赏； τ &gt;0称为“温度”， τ 越小则平均奖赏高的摇臂被选取的概率越高。特别的， τ -&gt;0时Softmax将趋于“仅利用”，  τ -&gt;无穷大时Softmax将趋于“仅探索”。</p><p>Softmax算法描述：</p><p>输入：摇臂数K；</p><p>​            奖赏函数R；</p><p>​            尝试次数T；</p><p>​            温度参数 τ </p><p>过程：</p><p>r=0；</p><p>任意vi=1，2，K：Q(i) = 0, count(i) = 0;</p><p>for t = 1,2,3,……,T do</p><p>​    k = 从1，2，……，K中根据Boltzmann分布随机选取</p><p>​    v= R(k);</p><p>​    r = r+v;</p><p>​    Q(k) = (Q(k)*count(k) + v)/(count(k) + 1)</p><p>​    count(k) = count(k)+1</p><p>end for</p><p>输出：累积奖赏r</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从《绿毛水怪》读王小波</title>
      <link href="/2019/10/31/lv-mao-shui-guai/"/>
      <url>/2019/10/31/lv-mao-shui-guai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“陈辉，你不该骗我的。”</p></blockquote><p>上一次读王小波的作品已经是一年前了，两部小说都在同家书店邂逅，那时读《革命时期的爱情》还不懂小波，现在读《绿毛水怪》已然是慨叹不已。都说喜欢某个作家是因为他的作品能引起自己的共鸣，那么王小波的作品可以引起我肺腑轰鸣。从首次接触他的作品——《友谊地久天长》那时起，我就发现我和他一样，都是淡淡忧伤的浪漫主义者，小波喜欢将自己的感情写进书里，他的幻想，理想，不能说的秘密，都被文字表现的极富张力。</p><p>《绿毛水怪》便是最具代表性的此类了。</p><p>故事是从男主老陈，也就是陈辉，向作者讲述开始，老陈深情又渴望地要开启他多年掩藏在心中的痛苦故事，可是作者在旁边当笑话听，故事还未开始便给全文蒙上了美与嘲讽的矛盾面纱。陈辉与杨素遥年少相识，通过一起反抗老师的“暴政”成为了好朋友，陈辉饿肚子了杨素遥会带他去自己家吃饭，陈辉爱好看书会带杨素遥一起去书店读平时读不到的好书，素遥被书本深深吸引的样子，不知不觉印在陈辉幼小的心灵里。两小无猜，却是懵懂中的相互依恋。小波描述了多么美好的童年时代，而这想必每个读者多少都能对号入座自己童年的那个TA吧，就在你沉浸在美好回忆中又好奇后续发展时，自然而然的，文章该进行感情转变了。</p><p>男女主从小学升入初中，由于政策原因去了不同的学校，一次转机让两人再次相遇， 杨素遥转进了陈辉的班。少年少女的心灵放佛未熟的青苹果，羞涩又萌动。陈辉放学便去追找素遥，然而两人却尴尬地前后走着，终于一个转角，女主俏皮地和男主正面接触了。童年的默契不是时光能随意抹去的，两人从此一起放学回家，彼此互相不说，彼此都不背弃。</p><blockquote><p>“这街景大概就像在水底，从一个月亮走向另一个月亮。”</p></blockquote><blockquote><p>“陈辉，你可以当个诗人。”</p></blockquote><p>诗人?这个词熟悉吧。没错，李银河正是这样评价王小波的。</p><p>悲剧就是将美好的东西撕碎给人看。陈辉终究与杨素遥分别去了不同地方工作，辗转两年都没联系，在通信不便的时代也算正常吧。待陈辉回到家偶然间翻出当初杨素遥送自己的书，悲剧开始了。</p><p>书里夹着杨素遥向他发出的留言条，尽管是邀请做客，可那个年代可就算是“交往”邀请了呢。待陈辉找到素遥家时，得知素遥溺死在了大海里，时间:两年前。</p><p>以前不懂为何留言条要注明具体日期，现在明白了，怕对方再看到时记不起时间。</p><p>比爱而不得更难过的是错过，小波果然厉害，时机卡的刚刚好。他是天生的悲观者，是柏拉图式爱情的忠实信徒，爱情这奢侈品，圣洁无比，超脱俗世的理解，怎轮得到他王小波拥有?可遇不可求，还就在你嘴边上。</p><p>那么绿毛水怪呢?讲了半天书名还没出现。别急，悲剧还不够悲，他要拼凑起来再撕一遍给你看。书里写到其实素遥没死，她忍受不了思念陈辉的痛苦，去海里当了绿毛水怪(没想到小波也能写超现实魔幻主义)。悲伤的陈辉到海边寻找素遥生前的痕迹，有情人终于偶然间相见了!多么幸福呀，超脱现实，超脱生死，世界还有什么放不下的呢？故事到这里结束该多好，小波觉得不够过瘾，他要写陈辉也去当绿毛水怪，永世和素遥在一起!</p><blockquote><p>“明天还在这块礁石等你。”</p></blockquote><p>天色已晚，海浪渐涨，咆哮的波涛要阻挡陈辉变成水怪的脚步!陈辉奋力游向岸边，他要与这大海搏斗，海浪疲倦了他的躯体，风寒侵蚀了他的脏器，陈辉终于因高烧被强制留在医院，未能赴约素遥。他疯狂地叫着她的名字，解释着这一切，不顾一切地抗争全世界……当陈辉终于跑出医院来到礁石时，只看到了素遥的留言: 陈辉，你不该骗我的，祝你在岸上幸福。</p><p>有时事情就是这样无法解释，怪谁呢?陈辉拼尽了全力去爱，素遥却受到两次背叛，这个世界是不是总爱开玩笑?</p><p>这正是王小波的爱情观。在遇见李银河之前，小波失恋，爱而不得，他悲伤的以为自己就是这个宿命，于是充分在文笔中宣泄，悲上加悲。老陈不是别人，就是小波自己，渴望爱情，可他的爱情总是在未开始就结束，卑微不?卑微得一点机会也不给。小说结尾，作者狠狠地嘲笑了老陈一番，“别编了，怎么会有这种事”，甚至又骂上一句。骂谁啊，实际在骂自己，放佛扇自己一耳光:“就你?幻想什么罗曼蒂克爱情啊，你配吗？”破罐子破摔，害，谁看得上我呀!</p><p>这就是小波作品的魅力，平凡故事中渲染淡淡的忧伤气氛，突然气氛憋爆，看在坐各位谁顶得住。喜欢小波，喜欢他的浪漫，他的孩子般矛盾内心，以及他纯洁的感情观。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> 书评 </tag>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019华为软件精英挑战赛</title>
      <link href="/2019/10/28/Huaweicoder/"/>
      <url>/2019/10/28/Huaweicoder/</url>
      
        <content type="html"><![CDATA[<p>参加过的一次华为软件精英挑战赛，虽然未能进入复赛，但是花费巨大精力码出长篇代码的酣畅淋漓感让我很难忘。赛题链接<a href="https://codecraft.huawei.com/Generaldetail" target="_blank" rel="noopener">https://codecraft.huawei.com/Generaldetail</a><br>我的代码：</p><pre><code>import threadingimport timeimport randomimport copydef minCmp(a, b):        &quot;&quot;&quot;return the min of two numbers&quot;&quot;&quot;        if a &lt; b:            min = a        else:            min = b        return mindef sort(lyst):        &quot;&quot;&quot;sort the schedule of the roads&quot;&quot;&quot;        quickSortHelper(lyst, 0, len(lyst) - 1) def swap(lyst, i, j):        &quot;&quot;&quot;change two elements&apos; position&quot;&quot;&quot;        t = lyst[i]        lyst[i] = lyst[j]        lyst[j] = tdef quickSortHelper(lyst, left, right):    if left &lt; right:        pivotLocation = partition(lyst, left, right)        quickSortHelper(lyst, left, pivotLocation - 1)        quickSortHelper(lyst, pivotLocation+1, right)def partition(lyst, left, right):    middle = (left + right) // 2    pivot = lyst[middle]    lyst[middle] = lyst[right]    lyst[right] = pivot    boundary = left    for index in range(left, right):        if lyst[index] &lt; pivot:            swap(lyst, index, boundary)            boundary += 1    swap(lyst, right, boundary)    return boundarydef find1(lyst, target):    &quot;&quot;&quot;find the target&quot;&quot;&quot;    position = 0    while position &lt; len(lyst):        if target == lyst[position]:            return position        position += 1    return -1def find2(lyst, target, i):    &quot;&quot;&quot;find the target depending on pivot.&quot;&quot;&quot;    position = 0    while position &lt; len(lyst):        if target == lyst[position][i]:            return position        position += 1    return -1def tailPosition(Road, laneNum, RoadLength):    &quot;&quot;&quot;return the tails lyst of different lanes of the next road.&quot;&quot;&quot;    tailLyst = []    for lane in range(laneNum):        tail = RoadLength - 1        while tail &gt;= 0:            if Road[tail][lane] != None:                break            tail -= 1        tailLyst.append(tail)    return tailLystdef passCross(carLyst, roadLyst, leftRoadInfoLyst, rightRoadInfoLyst, left):    &quot;&quot;&quot;calculate the positions of cars passing a cross once a time.    carLyst is the lyst of info of all cars: [[carID, start, end, maxSpeed, side, nexRoadID]].    roadLyst is the info of roads of this cross: [[id, length, mixSpeed, laneNum, startID, endID, isTwoDir]] (no None).    leftRoadInfoLyst is the matrix of the positions of left cars of this cross (no None).    rightRoadInfoLyst is the matrix of the positions of right cars of this cross (no None).&quot;&quot;&quot;    sortID = []    for road in roadLyst:        sortID.append(road[0])    sort(sortID)    sortRoad = []    for roadID in sortID:        for road in range(len(roadLyst)):            if roadID == roadLyst[road][0]:                sortRoad.append(rightRoadInfoLyst[road])                break    for road in range(len(sortRoad)):        if sortRoad[road][0] == 0:            continue        roadPosition = find1(rightRoadInfoLyst, sortRoad[road])                         # Get the speed matrix of roads        v1_lyst = copy.deepcopy(sortRoad[road])        for position in range(len(v1_lyst)):            for lane in range(len(v1_lyst[position])):                id = v1_lyst[position][lane]                if id != None:                    v1_lyst[position][lane] = minCmp(roadLyst[road][2], carLyst[find2(carLyst, id, 0)][3])        # Get the S1 of every car for one roads        s1 = copy.deepcopy(v1_lyst)        for position in range(len(s1)):            for lane in range(len(s1[position])):                if s1[position][lane] != None:                    s1[position][lane] = position        # Begin run        for position in range(len(sortRoad[road])):            for lane in range(len(sortRoad[road][position])):                id = sortRoad[road][position][lane]                if id == None:                    continue                # Judge the direction                nexRoadId = carLyst[find2(carLyst, sortRoad[road][position][lane], 0)][5]                nexRoadPosition = find2(roadLyst, nexRoadId, 0)                curRoadPosition = find1(rightRoadInfoLyst, sortRoad[road])                nexRoad = leftRoadInfoLyst[nexRoadPosition]                if abs(curRoadPosition-nexRoadPosition) == 2:                    # Go straight                    if s1[position][lane] &lt; v1_lyst[position][lane]:                        sv2 = minCmp(roadLyst[nexRoadPosition][2], carLyst[find2(carLyst, id, 0)][3])                        if s1[position][lane] &lt; sv2:                            s2 = sv2 - s1[position][lane]                            for nexlane in range(len(nexRoad[0])):                                tail = tailPosition(nexRoad, roadLyst[nexRoadPosition][3], roadLyst[nexRoadPosition][1])[nexlane]                                if tail == roadLyst[nexRoadPosition][1]-1:                                    continue                                if s2 &gt;= roadLyst[nexRoadPosition][1]-tail:                                    nexRoad[tail+1][nexlane] = id                                    if nexRoad in left:                                        carLyst[find2(carLyst, id, 0)][4] = 1                                    else:                                        carLyst[find2(carLyst, id, 0)][4] = 0                                    sortRoad[road][position][lane] = None                                    carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                    if nexRoad in left:                                        end = roadLyst[nexRoadPosition][4]                                    else:                                        end = roadLyst[nexRoadPosition][5]                                    if end == carLyst[find2(carLyst, id, 0)][2]:                                        nexRoad[tail+1][nexlane] = None                                else:                                    nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = id                                    if nexRoad in left:                                        carLyst[find2(carLyst, id, 0)][4] = 1                                    else:                                        carLyst[find2(carLyst, id, 0)][4] = 0                                    sortRoad[road][position][lane] = None                                              carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                    if nexRoad in left:                                        end = roadLyst[nexRoadPosition][4]                                    else:                                        end = roadLyst[nexRoadPosition][5]                                    if end == carLyst[find2(carLyst, id, 0)][2]:                                        nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = None                                break                        else:                            sortRoad[road][0][lane] = id                            sortRoad[road][position][lane] = None                    else:                        tail = tailPosition(sortRoad[road], len(sortRoad[road][0]), position)[lane]                        sortRoad[road][tail+1][lane] = id                        sortRoad[road][position][lane] = None                elif nexRoadPosition-curRoadPosition == 1 or nexRoadPosition-curRoadPosition == -3:                    canTurn = True                    for Road in range(len(sortRoad)):                        if sortRoad[Road][0] == 0:                            continue                        if sortRoad[Road] == sortRoad[road]:                            continue                        firstCar = None                        for nexPosition in sortRoad[Road]:                            for nextLane in nexPosition:                                if nextLane != None:                                    firstCar = nextLane                                    break                            if firstCar != None:                                break                        if firstCar == None:                            continue                        nex_RoadId = carLyst[find2(carLyst, firstCar, 0)][5]                        nex_RoadPosition = find2(roadLyst, nex_RoadId, 0)                        cur_RoadPosition = Road                        if abs(cur_RoadPosition-nex_RoadPosition) == 2:                            canTurn = False                    if canTurn:                        if s1[position][lane] &lt; v1_lyst[position][lane]:                            sv2 = minCmp(roadLyst[nexRoadPosition][2], carLyst[find2(carLyst, id, 0)][3])                            if s1[position][lane] &lt; sv2:                                s2 = sv2 - s1[position][lane]                                for nexlane in range(len(nexRoad[0])):                                    tail = tailPosition(nexRoad, roadLyst[nexRoadPosition][3], roadLyst[nexRoadPosition][1])[nexlane]                                    if tail == roadLyst[nexRoadPosition][1]-1:                                        continue                                    if s2 &gt;= roadLyst[nexRoadPosition][1]-tail:                                        nexRoad[tail+1][nexlane] = id                                        if nexRoad in left:                                            carLyst[find2(carLyst, id, 0)][4] = 1                                        else:                                            carLyst[find2(carLyst, id, 0)][4] = 0                                        sortRoad[road][position][lane] = None                                        carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                        if nexRoad in left:                                            end = roadLyst[nexRoadPosition][4]                                        else:                                            end = roadLyst[nexRoadPosition][5]                                        if end == carLyst[find2(carLyst, id, 0)][2]:                                            nexRoad[tail+1][nexlane] = None                                    else:                                        nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = id                                        if nexRoad in left:                                            carLyst[find2(carLyst, id, 0)][4] = 1                                        else:                                            carLyst[find2(carLyst, id, 0)][4] = 0                                        sortRoad[road][position][lane] = None                                        carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                        if nexRoad in left:                                            end = roadLyst[nexRoadPosition][4]                                        else:                                            end = roadLyst[nexRoadPosition][5]                                        if end == carLyst[find2(carLyst, id, 0)][2]:                                            nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = None                                    break                            else:                                sortRoad[road][0][lane] = id                                sortRoad[road][position][lane] = None                        else:                            tail = tailPosition(sortRoad[road], len(sortRoad[road][0]), position)[lane]                            sortRoad[road][tail+1][lane] = id                            sortRoad[road][position][lane] = None                else:                    canTurn = True                    for Road in range(len(sortRoad)):                        if sortRoad[Road][0] == 0:                            continue                        if sortRoad[Road] == sortRoad[road]:                            continue                        firstCar = None                        for nexPosition in sortRoad[Road]:                            for nextLane in nexPosition:                                if nextLane != None:                                    firstCar = nextLane                                    break                            if firstCar != None:                                break                        if  firstCar == None:                            continue                               nex_RoadId = carLyst[find2(carLyst, firstCar, 0)][5]                        nex_RoadPosition = find2(roadLyst, nex_RoadId, 0)                        cur_RoadPosition = Road                        if abs(cur_RoadPosition-nex_RoadPosition) == 2 or nexRoadPosition-curRoadPosition == 1 or nexRoadPosition-curRoadPosition == -3:                            canTurn = False                    if canTurn:                        if s1[position][lane] &lt; v1_lyst[position][lane]:                            sv2 = minCmp(roadLyst[nexRoadPosition][2], carLyst[find2(carLyst, id, 0)][3])                            if s1[position][lane] &lt; sv2:                                s2 = sv2 - s1[position][lane]                                for nexlane in range(len(nexRoad[0])):                                    tail = tailPosition(nexRoad, roadLyst[nexRoadPosition][3], roadLyst[nexRoadPosition][1])[nexlane]                                    if tail == roadLyst[nexRoadPosition][1]-1:                                        continue                                    if s2 &gt;= roadLyst[nexRoadPosition][1]-tail:                                        nexRoad[tail+1][nexlane] = id                                        if nexRoad in left:                                            carLyst[find2(carLyst, id, 0)][4] = 1                                        else:                                            carLyst[find2(carLyst, id, 0)][4] = 0                                        sortRoad[road][position][lane] = None                                        carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                        if nexRoad in left:                                            end = roadLyst[nexRoadPosition][4]                                        else:                                            end = roadLyst[nexRoadPosition][5]                                        if end == carLyst[find2(carLyst, id, 0)][2]:                                            nexRoad[tail+1][nexlane] = None                                    else:                                        nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = id                                        if nexRoad in left:                                            carLyst[find2(carLyst, id, 0)][4] = 1                                        else:                                            carLyst[find2(carLyst, id, 0)][4] = 0                                        sortRoad[road][position][lane] = None                                        carLyst[find2(carLyst, id, 0)][1] = nexRoadId                                        if nexRoad in left:                                            end = roadLyst[nexRoadPosition][4]                                        else:                                            end = roadLyst[nexRoadPosition][5]                                        if end == carLyst[find2(carLyst, id, 0)][2]:                                            nexRoad[roadLyst[nexRoadPosition][1]-s2][nexlane] = None                                    break                            else:                                sortRoad[road][0][lane] = id                                sortRoad[road][position][lane] = None                        else:                            tail = tailPosition(sortRoad[road], len(sortRoad[road][0]), position)[lane]                            sortRoad[road][tail+1][lane] = id                            sortRoad[road][position][lane] = None        rightRoadInfoLyst[roadPosition] = sortRoad[road]def findNextRoad(carLyst, roadLyst, crossLyst):    &quot;&quot;&quot;carLyst is the lyst of info of all cars: [[carID, currentRoad, endCross, maxSpeed, side, nexRoadID]].    roadLyst is the lyst of info of all roads: [[id, length, mixSpeed, laneNum, startID, endID, isTwoDir]] (no None).    crossLyst is the lyst of info of all crosses: [[[roadId1, roadId2, roadId3, roadId4]]].&quot;&quot;&quot;    for car in carLyst:        currentRoad = roadLyst[find2(roadLyst, car[1], 0)]        if car[4] == 1:            temp = currentRoad[4]            currentRoad[4] = currentRoad[5]            currentRoad[5] = temp        start = currentRoad[5]     #start cross:[x,y]          end = car[2]        if start[0] &gt; end[0] and start[1] &gt; end[1]:            # Northwest            weight = random.random()            if weight &lt; 0.5:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][1]                else:                    car.append(crossLyst[start[0]][start[1]][1])            else:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][0]                else:                    car.append(crossLyst[start[0]][start[1]][0])        elif start[0] &gt; end[0] and start[1] == end[1]:            # North            if len(car) != 5:                car[5] = crossLyst[start[0]][start[1]][1]            else:                car.append(crossLyst[start[0]][start[1]][1])        elif start[0] &gt; end[0] and start[1] &lt; end[1]:            # Northeast            weight = random.random()            if weight &lt; 0.5:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][2]                else:                    car.append(crossLyst[start[0]][start[1]][2])            else:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][1]                else:                    car.append(crossLyst[start[0]][start[1]][1])        elif start[0] == end[0] and start[1] &lt; end[1]:            # East            if len(car) != 5:                car[5] = crossLyst[start[0]][start[1]][2]            else:                car.append(crossLyst[start[0]][start[1]][2])        elif start[0] &lt; end[0] and start[1] &lt; end[1]:            # Southeast            weight = random.random()            if weight &lt; 0.5:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][2]                else:                    car.append(crossLyst[start[0]][start[1]][2])            else:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][3]                else:                    car.append(crossLyst[start[0]][start[1]][3])        elif start[0] &lt; end[0] and start[1] == end[1]:            # South            if len(car) != 5:                car[5] = crossLyst[start[0]][start[1]][3]            else:                car.append(crossLyst[start[0]][start[1]][3])        elif start[0] &lt; end[0] and start[1] &gt; end[1]:            # Southwest            weight = random.random()            if weight &lt; 0.5:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][3]                else:                    car.append(crossLyst[start[0]][start[1]][3])            else:                if len(car) != 5:                    car[5] = crossLyst[start[0]][start[1]][0]                else:                    car.append(crossLyst[start[0]][start[1]][0])        else:            # West            if len(car) != 5:                car[5] = crossLyst[start[0]][start[1]][0]            else:                car.append(crossLyst[start[0]][start[1]][0])        if car[4] == 1:            temp = currentRoad[4]            currentRoad[4] = currentRoad[5]            currentRoad[5] = tempdef outCar(carLyst):    &quot;&quot;&quot;put cars which achieve the end out of roads.&quot;&quot;&quot;    for car in carLyst:        if car[4] == 1:            end = roadLyst[find2(roadLyst, car[1], 0)][4]        else:            end = roadLyst[find2(roadLyst, car[1], 0)][5]        if end == car[2]:            carLyst.remove(car)def initLine(carLyst):    &quot;&quot;&quot; Init the roadlines of cars.&quot;&quot;&quot;    line = []    for car in carLyst:        line.append([car[0], car[1]])    return linedef carLine(carLyst, line):    &quot;&quot;&quot;Return the roadLines of cars.&quot;&quot;&quot;    for car in carLyst:        line[find2(line, car[0], 0)].append(car[1])#class myThread(threading.Thread):#    def __init__(self, crossID, roadLyst, carLyst, crossLyst, leftRoadInfoLyst, rightRoadInfoLyst, left, line):#        threading.Thread.__init__(self)#        self.threadID = crossID#        self.roadLyst = roadLyst#        self.carLyst = carLyst#        self.crossLyst = crossLyst#        self.leftRoadInfoLyst = leftRoadInfoLyst#        self.rightRoadInfoLyst = rightRoadInfoLyst#        self.left = left#        self.line = line#    def run(self):#        print(&quot;threadID&quot;, self.threadID)#        findNextRoad(self.carLyst, self.roadLyst, self.crossLyst)#        passCross(self.carLyst, self.roadLyst, self.leftRoadInfoLyst, self.rightRoadInfoLyst, self.left)#        carLine(self.carLyst, self.line)#        outCar(self.carLyst)#        print(self.line)carLyst = [[100, 1000, [2,2], 4, 0],        [101, 1000, [2,2], 3, 0],        [102, 1000, [2,2], 3, 0],        [103, 1000, [2,1], 4, 0],        [104, 1000, [1,0], 4, 1],        [105, 1001, [0,1], 5, 0],        [106, 1001, [0,2], 5, 0],        [107, 1001, [2,0], 4, 1],        [108, 1002, [0,0], 7, 1],        [109, 1002, [1,2], 7, 0],        [110, 1002, [1,2], 6, 0],        [111, 1002, [1,2], 6, 0],        [112, 1002, [1,1], 6, 0],        [113, 1002, [1,0], 5, 1],        [114, 1002, [0,1], 5, 0],        [115, 1002, [0,0], 6, 1],        [116, 1002, [0,1], 4, 0],        [117, 1003, [1,0], 4, 1],        [118, 1003, [2,2], 5, 0],        [119, 1003, [0,0], 4, 1],        [120, 1004, [1,0], 5, 1],        [121, 1005, [2,0], 6, 1],        [122, 1005, [0,2], 7, 0],        [123, 1006, [0,2], 3, 1],        [124, 1007, [1,2], 4, 0],        [125, 1007, [2,2], 5, 0],        [126, 1007, [1,0], 6, 0],        [127, 1007, [1,2], 7, 0],        [128, 1007, [2,0], 3, 0],        [129, 1008, [2,1], 4, 0],        [130, 1008, [2,2], 5, 0],        [131, 1008, [0,0], 6, 1],        [132, 1008, [1,0], 7, 0],        [133, 1008, [2,0], 3, 0],        [134, 1008, [0,1], 4, 1],        [135, 1009, [1,2], 5, 1],        [136, 1009, [2,2], 6, 0],        [137, 1010, [0,0], 7, 1],        [138, 1011, [0,1], 3, 1],        [139, 1011, [0,2], 5, 1],        [140, 1011, [2,0], 6, 0]]roadLyst = [[1000, 10, 3, 3, [0,0], [0,1], 1],                 [1001, 10, 4, 3, [1,0], [1,1], 1],            [1002, 10, 5, 3, [2,0], [2,1], 1],            [1003, 10, 3, 3, [0,1], [0,2], 1],            [1004, 10, 4, 4, [1,1], [1,2], 1],            [1005, 10, 2, 4, [2,1], [2,2], 1],            [1006, 10, 5, 3, [0,0], [1,0], 1],            [1007, 10, 4, 3, [0,1], [1,1], 1],            [1008, 10, 3, 3, [0,2], [1,2], 1],            [1009, 10, 4, 4, [1,0], [2,0], 1],            [1010, 10, 5, 4, [1,1], [2,1], 1],            [1011, 10, 3, 4, [1,2], [2,2], 1],            [0,    0,  0, 0, 0,     0,     0]]crossLyst = [[[0, 0, 1000, 1006],[1000, 0, 1003, 1007],[1003, 0, 0, 1008]],            [[0, 1006, 1001, 1009],[1001, 1007, 1004, 1010],[1004, 1008, 0, 1011]],            [[0, 1009, 1002, 0],[1002, 1010, 1005, 0],[1005, 1011, 0, 0]]]right = [[[100, 101, 102],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[105, 106, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[109, None, None],        [110, 111, None],        [112, None, None],        [114, None, None],        [116, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[118, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[122, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[124, 126, 125],        [127, 128, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[129, 130, 132],        [133, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[136, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[None, 140, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]]]left = [[[None, 103, 104],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[None, 107, 108],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[None, None, None],        [113, None, None],        [115, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[117, 119, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[120, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[121, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[123, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[None, 127, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[131, 134, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]],        [[135, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[137, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[138, 139, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None],        [None, None, None, None]],        [[None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None],        [None, None, None]]]line = initLine(carLyst)#thread1 = myThread([0,0], [roadLyst[12], roadLyst[12], roadLyst[0],roadLyst[6]], carLyst, crossLyst, [left[12], left[12], right[0], right[6]], [right[12], right[12], left[0], left[6]], left, line)#thread2 = myThread([0,1], [roadLyst[0], roadLyst[12], roadLyst[3],roadLyst[7]], carLyst, crossLyst, [left[0], left[12], right[3], right[7]], [right[0], right[12], left[3], left[7]], left, line)#thread3 = myThread([0,2], [roadLyst[3], roadLyst[12], roadLyst[12],roadLyst[8]], carLyst, crossLyst, [left[3], left[12], right[12], right[8]], [right[3], right[12], left[12], left[8]], left, line)#thread4 = myThread([1,0], [roadLyst[12], roadLyst[6], roadLyst[1],roadLyst[9]], carLyst, crossLyst, [left[12], left[6], right[1], right[9]], [right[12], right[6], left[1], left[9]], left, line)#thread5 = myThread([1,1], [roadLyst[1], roadLyst[7], roadLyst[4],roadLyst[10]], carLyst, crossLyst, [left[1], left[7], right[4], right[10]], [right[1], right[7], left[4], left[10]], left, line)#thread6 = myThread([1,2], [roadLyst[4], roadLyst[8], roadLyst[12],roadLyst[11]], carLyst, crossLyst, [left[4], left[8], right[12], right[11]], [right[4], right[8], left[1], left[7]], left, line)#thread7 = myThread([2,0], [roadLyst[12], roadLyst[9], roadLyst[2],roadLyst[12]], carLyst, crossLyst, [left[12], left[9], right[2], right[12]], [right[12], right[9], left[2], left[12]], left, line)#thread8 = myThread([2,1], [roadLyst[2], roadLyst[10], roadLyst[5],roadLyst[12]], carLyst, crossLyst, [left[2], left[10], right[5], right[0]], [right[2], right[10], left[5], left[12]], left, line)#thread9 = myThread([2,2], [roadLyst[5], roadLyst[11], roadLyst[12],roadLyst[12]], carLyst, crossLyst, [left[5], left[11], right[12], right[12]], [right[5], right[11], left[12], left[12]], left, line)#thread1.start()#thread2.start()#thread3.start()#thread4.start()#thread5.start()#thread6.start()#thread7.start()#thread8.start()#thread9.start()while True:    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[12], roadLyst[12], roadLyst[0],roadLyst[6]], [left[12], left[12], right[0], right[6]], [right[12], right[12], left[0], left[6]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[0], roadLyst[12], roadLyst[3],roadLyst[7]], [left[0], left[12], right[3], right[7]], [right[0], right[12], left[3], left[7]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[3], roadLyst[12], roadLyst[12],roadLyst[8]], [left[3], left[12], right[12], right[8]], [right[3], right[12], left[12], left[8]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[12], roadLyst[6], roadLyst[1],roadLyst[9]], [left[12], left[6], right[1], right[9]], [right[12], right[6], left[1], left[9]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[1], roadLyst[7], roadLyst[4],roadLyst[10]], [left[1], left[7], right[4], right[10]], [right[1], right[7], left[4], left[10]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[4], roadLyst[8], roadLyst[12],roadLyst[11]], [left[4], left[8], right[12], right[11]], [right[4], right[8], left[1], left[7]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[12], roadLyst[9], roadLyst[2],roadLyst[12]], [left[12], left[9], right[2], right[12]], [right[12], right[9], left[2], left[12]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[2], roadLyst[10], roadLyst[5],roadLyst[12]], [left[2], left[10], right[5], right[0]], [right[2], right[10], left[5], left[12]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    findNextRoad(carLyst, roadLyst, crossLyst)    passCross(carLyst, [roadLyst[5], roadLyst[11], roadLyst[12],roadLyst[12]], [left[5], left[11], right[12], right[12]], [right[5], right[11], left[12], left[12]], left)    carLine(carLyst, line)    outCar(carLyst)    if len(carLyst) == 0:        break    print(carLyst)    print(&quot;\n&quot;)print(rows for row in line)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 项目 </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘制3D图像</title>
      <link href="/2019/10/28/3D-Picture-python/"/>
      <url>/2019/10/28/3D-Picture-python/</url>
      
        <content type="html"><![CDATA[<p>首先导入需要的第三方库</p><pre><code>import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D</code></pre><p>然后创建数据集</p><pre><code>dataSet = [[91, 85, 52, 2], [40, 55, 13, 1], [41, 36, 93, 4], [52, 10, 63, 4], [1, [52, 74, 40, 2], [70, 7, 1, 1], [94, 97, 82, 2], [15, 100, 52, 3], [6, [67, 36, 56, 4], [84, 41, 11, 2], [55, 84, 97, 2], [5, 63, 94, 3], [1 [67, 46, 5, 2], [0, 76, 5, 1], [8, 57, 13, 1], [89, 95, 67, 2], [95, 467, 52, 94, 4], [64, 93, 79, 2], [23, 61, 84, 3], [78, 10, 34, 4], [32, [20, 42, 27, 1], [77, 62, 38, 2], [97, 17, 52, 4], [18, 98, 58, 3], [5 [24, 14, 90, 4], [48, 75, 37, 2], [76, 97, 100, 2], [4, 1, 4, 1], [19,, [36, 68, 70, 3], [30, 33, 7, 1], [89, 70, 70, 2], [98, 71, 69, 2], [3], [57, 36, 95, 4], [34, 87, 24, 3], [1, 78, 66, 3], [76, 27, 52, 4], [], [27, 33, 77, 3], [69, 83, 80, 2], [27, 38, 3, 1], [94, 20, 68, 4], [4], [31, 71, 51, 3], [28, 4, 65, 1], [41, 57, 85, 3], [65, 1, 54, 4], [1], [90, 86, 15, 2], [85, 65, 33, 2], [3, 23, 35, 1], [0, 6, 34, 1], [2, [60, 21, 95, 4], [69, 18, 34, 4], [10, 39, 33, 1]]</code></pre><p>由于本实例中的数据集包含四个种类的散点，因此需要分别创建四个散点数据集来分开展示</p><pre><code>dataSet1 = []dataSet2 = []dataSet3 = []dataSet4 = []</code></pre><p>分别向4个类别散点集中添加点，将每个点坐标列表末尾的类别数字去除</p><pre><code>for point in list:    if point[-1] == 1:        dataSet1.append(point[:-1])    elif point[-1] == 2:        dataSet2.append(point[:-1])    elif point[-1] == 3:        dataSet3.append(point[:-1])    else:        dataSet4.append(point[:-1])</code></pre><p>分别创建坐标轴数据集</p><pre><code>x1 = np.array(dataSet1)[:, 0]y1 = np.array(dataSet1)[:, 1]z1 = np.array(dataSet1)[:, 2]x2 = np.array(dataSet2)[:, 0]y2 = np.array(dataSet2)[:, 1]z2 = np.array(dataSet2)[:, 2]x3 = np.array(dataSet3)[:, 0]y3 = np.array(dataSet3)[:, 1]z3 = np.array(dataSet3)[:, 2]x4 = np.array(dataSet4)[:, 0]y4 = np.array(dataSet4)[:, 1]z4 = np.array(dataSet4)[:, 2]</code></pre><p>创建图像</p><pre><code>fig = plt.figure()</code></pre><p>创建3D图像对象</p><pre><code>ax = Axes3D(fig)</code></pre><p>设计散点图属性</p><pre><code>ax.scatter(x1, y1, z1, marker=&quot;*&quot;, c=&apos;r&apos;, label=&apos;class1&apos;)ax.scatter(x2, y2, z2, marker=&quot;*&quot;, c=&apos;g&apos;, label=&apos;class2&apos;)ax.scatter(x3, y3, z3, marker=&quot;*&quot;, c=&apos;b&apos;, label=&apos;class3&apos;)ax.scatter(x4, y4, z4, marker=&quot;*&quot;, c=&apos;y&apos;, label=&apos;class4&apos;)</code></pre><p>绘制图例，best表示图例位置为最适位置</p><pre><code>ax.legend(loc=&apos;best&apos;)</code></pre><p>添加坐标轴(注意顺序为Z,Y,X)</p><pre><code>ax.set_zlabel(&apos;Z&apos;, fontdict={&apos;size&apos;: 15, &apos;color&apos;: &apos;red&apos;})ax.set_ylabel(&apos;Y&apos;, fontdict={&apos;size&apos;: 15, &apos;color&apos;: &apos;red&apos;})ax.set_xlabel(&apos;X&apos;, fontdict={&apos;size&apos;: 15, &apos;color&apos;: &apos;red&apos;})</code></pre><p>展示</p><pre><code>plt.show()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小谈NoSQL</title>
      <link href="/2019/10/28/NoSQL-Summary/"/>
      <url>/2019/10/28/NoSQL-Summary/</url>
      
        <content type="html"><![CDATA[<h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><ul><li>NoSQL简介</li><li>NoSQL兴起的原因</li><li>NoSQL与关系数据库的比较</li><li>NoSQL的四大类型</li><li>NoSQL的三大基石</li><li>从NoSQL到NewSQL数据库</li><li>文档数据库MongoDB</li></ul><hr><h3 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h3><p>从最初表示的“反SQL”运动，用新型的非关系型数据库取代关系型数据库，发展为现在表示关系和非关系型数据库各有优缺点彼此都无法互相取代，即“Not only SQL”。</p><p>通常，NoSQL数据库具有以下特点：</p><ul><li>灵活的可扩展性</li><li>灵活的数据模型</li><li>与云计算紧密融合</li></ul><hr><h3 id="NoSQL兴起的原因"><a href="#NoSQL兴起的原因" class="headerlink" title="NoSQL兴起的原因"></a>NoSQL兴起的原因</h3><ul><li>关系数据库已经无法满足Web2.0的需求。主要表现在：<ul><li>无法满足海量数据的管理需求</li><li>无法满足数据高并发的需求</li><li>无法满足高可拓展性和高可用性的需求</li></ul></li><li>MySQL集群存在的问题：<ul><li><strong>复杂性</strong>：部署、管理、配置很复杂</li><li><strong>数据库复制</strong>：MySQL主备之间采用复制方式，只能是异步复制，当主库压力较大时可能产生较大延迟，主备切换会丢失最后一部分更新事务，这时往往需要人工介入，备份和恢复不方便。</li><li><strong>扩容问题</strong>：如果系统压力过大需要增加新的机器，这个过程涉及数据重新划分，整个过程比较复杂，且容易出错。</li><li><strong>动态数据迁移问题</strong>：如果某个数据库组压力过大，需要将其中部分数据迁移出去，迁移过程需要总控节点整体协调，以及数据库节点的配合。这个过程很难做到自动化。</li></ul></li><li>“One size fits all”模式很难适用于截然不同的业务场景。比如Hadoop针对数据分析，强调高吞吐，而MongoDB、Redis等是针对在线业务，强调低延时，两者都抛弃了关系模型。</li><li>关系数据库引以为傲的关键特性——完善的事务机制和高效的查询机制到了Web2.0时代却成了鸡肋，主要表现在以下几个方面：<ul><li>Web2.0网站系统通常不要求严格的数据库事务</li><li>Web2.0并不要求严格的读写实时性</li><li>Web2.0通常不包含大量复杂的SQL查询（去结构化，存储空间更换更好的查询性能）</li></ul></li></ul><hr><h3 id="NoSQL与关系数据库的比较"><a href="#NoSQL与关系数据库的比较" class="headerlink" title="NoSQL与关系数据库的比较"></a>NoSQL与关系数据库的比较</h3><ul><li>关系数据库<ul><li><strong>优势</strong>：以完善的关系代数理论作为基础，有严格的标准，支持事务ACID四性，借助索引机制可以实现高效的查询，技术成熟，有专业公司的技术支持</li><li><strong>劣势</strong>：可扩展性较差，无法较好支持海量数据存储，数据模型过于死板、无法较好支持Web2.0应用，事务机制影响了系统的整体性能等</li><li><strong>应用场景</strong>：电信、银行等领域的关键业务系统，需要保证强事务一致性。</li></ul></li><li>NoSQL数据库<ul><li><strong>优势</strong>：可以支持超大规模数据存储，灵活的数据模型可以很好地支持Web2.0应用，具有强大的横向扩展能力等</li><li><strong>劣势</strong>：缺乏数学理论基础，复杂查询性能不高，大都不能实现事务强一致性，很难实现数据完整性，技术尚不成熟，缺乏专业团队的技术支持，维护较困难等</li><li><strong>应用场景</strong>：互联网企业、传统企业的非关键业务（比如数据分析）</li></ul></li></ul><p>当然也可以采用混合架构</p><h3 id="NoSQL的四大类型"><a href="#NoSQL的四大类型" class="headerlink" title="NoSQL的四大类型"></a>NoSQL的四大类型</h3><ul><li><p>文档数据库：MarkLogic，Couchbase，mongoDB</p><ul><li><p>数据模型：键/值</p><p>​                   值（value）是版本化的文档</p></li><li><p>典型应用：存储、索引并管理面向文档的数据或者类似的半结构化数据</p><p>比如，用于后台具有大量读写操作的网站、使用JSON数据结构的应用、使用嵌套结构等非规范化数据的应用程序</p></li><li><p>优点：性能好（高并发），灵活性高，复杂性低，数据结构灵活</p><p>提供嵌入式文档功能，将经常查询的数据存储在同一个文档中</p><p>既可以根据键来构建索引，也可以根据内容构建索引</p></li><li><p>缺点：缺乏统一的查询语法</p></li><li><p>不适用情形：在不同的文档上添加事务。文档数据库并不支持文档间的事务，如果对这方面有需求则不应该选用这个解决方案</p></li></ul></li><li><p>图数据库：Neo4j，InfiniteGraph</p><ul><li>数据模型：图结构</li><li>典型应用：专门用于处理具有高度相互关联关系的数据，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题</li><li>优点：灵活性高，支持复杂的图形算法，可用于构建复杂的关系图谱</li><li>缺点：复杂性高，只能支持一定的数据规模</li></ul></li><li><p>键值数据库：redis、amazonDynameDB、riak、aerospike</p><ul><li><p>数据模型：键/值对</p><p>​                   键是一个字符串对象</p><p>​                   值可以是任意类型的数据，比如整型、字符型、数组、列表、集合等</p></li><li><p>典型应用：涉及频繁读写、拥有简单数据模型的应用</p><p>​                   内容缓存，比如会话、配置文件、参数、购物车等</p><p>​                   存储配置和用户数据信息的移动应用</p></li><li><p>优点：扩展性好，灵活性好，大量写操作时性能高</p></li><li><p>缺点：无法存储结构化信息，条件查询效率较低</p></li><li><p>不适用情形：不是通过键而是通过值来查：键值数据库根本没有通过值查询的途径</p><p>需要存储数据之间的关系：在键值数据库中，不能通过两个或两个以上的键来关联数据 </p><p>需要事务的支持：在一些键值数据库中，产生故障时，不可以回滚</p></li></ul></li><li><p>列族数据库：accumulo、Hypertable、cassandra、HBase、Amazon SimipleDB</p><ul><li><p>数据模型：列族</p></li><li><p>典型应用：分布式数据存储与管理</p><p>​                   数据在地理上分布于多个数据中心的应用程序</p><p>​                   可以容忍副本中存在短期不一致情况的应用程序</p><p>​                   拥有动态字段的应用程序</p><p>​                   拥有潜在大量数据的应用程序，大到几百TB的数据</p></li><li><p>优点：查找速度快，可扩展性强，容易进行分布式扩展，复杂性低</p></li><li><p>缺点：功能较少，大都不支持强事务一致性</p></li><li><p>不适用情形：需要ACID事务支持的情形，Cassandra等产品就不适用</p></li></ul></li></ul><hr><h3 id="NoSQL三大基石"><a href="#NoSQL三大基石" class="headerlink" title="NoSQL三大基石"></a>NoSQL三大基石</h3><p><strong>CAP</strong></p><ul><li><strong>C（Consistency）</strong>：一致性，是指任何一个读操作总是能够读到之前完成的写操作的结果，也就是在分布式环境中，多点的数据是一致的，或者说，所有节点在同一时间具有相同的数据</li><li><strong>A（Availability）</strong>：可用性，是指快速获取数据，可以在确定的时间内返回操作结果，保证每个请求不管成功或者失败都有响应</li><li><strong>P（Tolerance of Network Partition）</strong>：分区容忍性，是指当出现网络分区的情况时（即系统中的一部分节点无法和其他节点进行通信），分离的系统也能够正常运行，也就是说，系统中任意信息的丢失或失败不会影响系统的继续运作。</li></ul><p>CAP理论告诉我们，一个分布式系统不可能同时满足一致性、可用性和分区容忍性这三个需求，最多只能同时满足其中两个，正所谓“鱼和熊掌不可兼得”。</p><p>当处理CAP的问题时，可以有几个明显的选择：</p><ul><li><p><strong>CA</strong>：也就是强调一致性（C）和可用性（A），放弃分区容忍性（P），最简单的做法是把所有与事务相关的内容都放到同一台机器上。很显然，这种做法会严重影响系统的可扩展性。传统的关系数据库（MySQL、SQL Server和PostgreSQL），都采用了这种设计原则，因此，扩展性都比较差</p></li><li><p><strong>CP</strong>：也就是强调一致性（C）和分区容忍性（P），放弃可用性（A），当出现网络分区的情况时，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务</p></li><li><p><strong>AP</strong>：也就是强调可用性（A）和分区容忍性（P），放弃一致性（C），允许系统返回不一致的数据</p></li></ul><p><strong>BASE</strong></p><p>一个数据库事务具有ACID四性：</p><ul><li><p>A（Atomicity）：原子性，是指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行</p></li><li><p>C（Consistency）：一致性，是指事务在完成时，必须使所有的数据都保持一致状态</p></li><li><p>I（Isolation）：隔离性，是指由并发事务所做的修改必须与任何其它并发事务所做的修改隔离</p></li><li><p>D（Durability）：持久性，是指事务完成之后，它对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持</p></li></ul><p>BASE的基本含义是</p><ul><li>基本可用（Basically Availble）：基本可用，是指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用，也就是允许分区失败的情形出现</li><li>软状态（Soft-state）：“软状态（soft-state）”是与“硬状态（hard-state）”相对应的一种提法。数据库保存的数据是“硬状态”时，可以保证数据一致性，即保证数据一直是正确的。“软状态”是指状态可以有一段时间不同步，具有一定的滞后性</li><li>最终一致性（Eventual consistency）：一致性的类型包括强一致性和弱一致性，二者的主要区别在于高并发的数据访问操作下，后续操作是否能够获取最新的数据。对于强一致性而言，当执行完一次更新操作后，后续的其他读操作就可以保证读到更新后的最新数据；反之，如果不能保证后续访问读到的都是更新后的最新数据，那么就是弱一致性。而最终一致性只不过是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但是经过一段时间之后，必须最终读到更新后的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 时空大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空大数据介绍-2</title>
      <link href="/2019/10/28/Time-Space-Big-Data-2/"/>
      <url>/2019/10/28/Time-Space-Big-Data-2/</url>
      
        <content type="html"><![CDATA[<h2 id="时空大数据平台"><a href="#时空大数据平台" class="headerlink" title="时空大数据平台"></a>时空大数据平台</h2><h3 id="何谓时空大数据平台"><a href="#何谓时空大数据平台" class="headerlink" title="何谓时空大数据平台"></a>何谓时空大数据平台</h3><p>​        时空大数据平台是把各种分散的（点数据）和分割的（条数据）大数据汇聚到一个特定的平台上（时空数据或地理框架数据平台），通过数据多维融合和关联分析与数据挖掘，揭示事物的本质规律，对事物做出更加快捷、更加全面、更加精准和更加有效的研判和预判，从而使之发生持续的聚合效应。</p><h3 id="“通用时空大数据平台-”模式"><a href="#“通用时空大数据平台-”模式" class="headerlink" title="“通用时空大数据平台+”模式"></a>“通用时空大数据平台+”模式</h3><ul><li><p>通用时空大数据平台：</p><p>“大数据”之“大”就在于将各种分散的数据彼此联系，由“点”而“线”，由“线”而“面”，由“面”而“层次”，以形成更完整的覆盖面，更清楚的理解事物的本质和未来的趋势。这就是“数聚力量”。</p><p>包括：时空基准数据，GNSS与CORS数据，天空地海一体遥感数据，数字高程模型数据，数字正射影像数据，矢量数字地图数据，海洋测绘与海图数据，全球地名数据，时空基准数据。</p></li><li><p>通用时空大数据平台+军用</p><p>由天空地海一体传感网将数据传入大数据平台，处理过后将数据传出到一体化指挥的时空大数据平台、公共作战态势图（COP）、地理空间情报等。</p><p>包括：战场工程数据、战场兵要数据、战场移动目标数据、战场态势数据、战场兵力数据、情报数据、战场固定基地数据等。</p></li><li><p>“通用时空大数据平台+”民用</p><p>由天空地海一体传感网将数据传入大数据平台，处理后将数据传出到新型智慧城市各部门业务应用系统、政府综合决策支持系统。</p><p>包括：人社数据、水利数据、交通数据、公安数据、人口数据、电力数据、资源数据、教育数据等。</p></li></ul><h3 id="时空大数据平台的基本功能"><a href="#时空大数据平台的基本功能" class="headerlink" title="时空大数据平台的基本功能"></a>时空大数据平台的基本功能</h3><ul><li>传感器网分类接入（实时动态）</li><li>时空大数据分布式存储和管理</li><li>时空数据与各部门（行业）多源异构时空大数据聚合、共享、交换</li><li>时空大数据统计分析、数据挖掘与知识发现</li><li>时空大数据可视化</li><li>知识服务和辅助指挥决策</li><li>时空大数据网络空间安全监控与防范</li></ul><h3 id="时空大数据平台构建"><a href="#时空大数据平台构建" class="headerlink" title="时空大数据平台构建"></a>时空大数据平台构建</h3><ul><li><p>构建一个开放的体系架构，强化公用，整合通用，开放应用</p><p>由三个角色和四个基本操作构成：</p><ul><li>服务注册（描述/发布）</li><li>服务查找（访问/定位）</li><li>绑定服务</li><li>调用服务</li></ul></li><li><p>构建一个通用的功能平台，通过服务化封装，实现各类信息资源的高效调用、支撑信息服务的智能化。</p></li><li><p>构建一个开放共享的数据体系，通过多源异构时空大数据的融合（整合或聚合），形成一致性的数据集（全球一致、陆海一体、无缝连续），通过统计分析和挖掘，进一步提升治理体系和指挥决策的现代化水平。</p><p>由传感网和各部门（行业）数据库接入时空大数据（中心），进行分布式存储管理，再提取数据到多源异构时空大数据融合，形成一致性数据集，再对其进行数据统计分析与数据挖掘，将数据化为知识，从而辅助决策，达到指挥决策智能化。</p></li><li><p>构建一个高效运行的管理指挥体系，实现信息资源的汇聚共享和跨部门的协调联动，为时空大数据平台安全可靠运行提供支撑。</p></li><li><p>构建一个高效运行的管理指挥体系，实现信息资源的汇聚共享和跨部门的协调联动，为时空大数据平台安全可靠运行提供支撑。</p></li><li><p>建立一套统一的标准体系，保证时空大数据平台规范、有序、健康、安全、可持续运行。</p></li></ul><p>现状：</p><ul><li>国外：地理信息标准和网络/网格（栅格网）服务的标准基本已成体系。</li><li>国内：地理信息标准已基本成体系，但网络/网格服务标准基本上参照国外的，未形成自主的体系。</li></ul><p>​       </p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时空大数据 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空大数据介绍-1</title>
      <link href="/2019/10/28/Time-Space-Big-Data-1/"/>
      <url>/2019/10/28/Time-Space-Big-Data-1/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要提出时空大数据"><a href="#为什么要提出时空大数据" class="headerlink" title="为什么要提出时空大数据"></a>为什么要提出时空大数据</h2><h3 id="从哲学层面看"><a href="#从哲学层面看" class="headerlink" title="从哲学层面看"></a>从哲学层面看</h3><p>​        空间与时间一起构成运动着的物质存在的两种基本形式。空间指物质存在的广延性；时间指物质运动过程的持续性和顺序性。空间和时间具有客观性，同运动着的物质不可分割。没有脱离物质运动的空间和时间，也没有不在空间和时间中运动的物质。空间和时间也是相互联系的。现代物理学的发展，特别是相对论，证明空间和时间同运动着的物质的不可分割的联系。</p><h3 id="从运动着的万事万物表达的层面看"><a href="#从运动着的万事万物表达的层面看" class="headerlink" title="从运动着的万事万物表达的层面看"></a>从运动着的万事万物表达的层面看</h3><ul><li><p>时间维（T）</p><blockquote><p>指地理信息随时间变化，具有时态性，需要有一个精确的时间基准。</p></blockquote></li><li><p>空间维（S-XYZ）</p><blockquote><p>指地理信息具有精确的空间位置或空间分布特征，具有可量测性，需要一个精确的空间基准。</p></blockquote></li><li><p>属性维（D）</p><blockquote><p>指空间上可加载随时间变化的要素（现象）的各种相关信息（属性信息），具有多维特征，需要有一个科学的分类体系和标准的编码体系。</p></blockquote></li></ul><h3 id="从提升社会治理体系和治理能力现代化水平的层面看"><a href="#从提升社会治理体系和治理能力现代化水平的层面看" class="headerlink" title="从提升社会治理体系和治理能力现代化水平的层面看"></a>从提升社会治理体系和治理能力现代化水平的层面看</h3><p>​        随着全球化进程的加快，当今社会的一个重要特点是，世界（区域、国家、城市）管理和治理对时间和空间的依赖程度越来越高，时空大数据正日益成为全球（区域、国家、城市）治理体系和治理能力现代化的核心驱动力。中国在全球治理中负有大国担当的重任。</p><h3 id="从提升指挥决策现代化水平的层面看"><a href="#从提升指挥决策现代化水平的层面看" class="headerlink" title="从提升指挥决策现代化水平的层面看"></a>从提升指挥决策现代化水平的层面看</h3><p>​        进入21世纪，太空成为继核武器之后的新型战略威慑力量，与核威慑、网络威慑交织融合，共同构成新的战略稳定架构；太空实现全球作战力量一体化，具有天然的全球性和跨域性，全球任何地方的作战力量和手段都能通过“天地一体网”连接起来，形成一体化作战力量体系。要想从太空在任何时间、任何地点、任何气象条件下打击地球上任何一个目标，必须有全球一体化的时空大数据平台保障。</p><h3 id="从未来无人作战（无人驾驶）的需求层面看"><a href="#从未来无人作战（无人驾驶）的需求层面看" class="headerlink" title="从未来无人作战（无人驾驶）的需求层面看"></a>从未来无人作战（无人驾驶）的需求层面看</h3><p>​        如今中国的无人作战飞机已跻身世界先进行列，无人机“蜂群”作战越来越受到重视，时空大数据正是这一作战技术的核心要点。</p><h2 id="什么是时空大数据"><a href="#什么是时空大数据" class="headerlink" title="什么是时空大数据"></a>什么是时空大数据</h2><ul><li><p>内涵：</p><p><strong>时空大数据</strong>，指基于统一的时空基准（空间参照系统、时间参照系统），活动（运动变化）于时间和空间中与位置直接（定位）或间接（空间分布）相关联的大数据。</p></li><li><p>界定时空大数据的三个基本事实：</p><ul><li>世界是物质的，物质是运动的，包括人类活动在内的万事万物的运动变化都是在一定的时间和空间中进行的，而所有的大数据都是世界万事万物运动变化的产物</li><li>随着智能感知技术、物联网、云计算技术的发展，各个领域开始了“量化”的进程，这种一切皆可“量化”（数字化）的趋势导致了大规模海量数据的产生，而空间参照与时间参照是大数据的两个基本特征；</li><li>从可视化角度讲，正是因为一切大数据都具有空间参照与时间参照特征，所以才能直观地为人们提供大数据的空间位置、空间分布的具体信息。</li></ul></li><li><p>时空大数据的主要类型：</p><ul><li>地理空间框架数据：<ul><li>时空基准数据</li><li>GNSS及CORS数据</li><li>空间大地测量和物理测量数据</li><li>海洋测绘和海图数据</li><li>摄影测量数据</li><li>遥感影像数据</li><li>地图数据</li><li>地名数据</li><li>世界海峡数据</li><li>其他星球（如月球）地形数据</li></ul></li><li>时空变化数据：<ul><li>视频观测数据</li><li>搜索引擎数据</li><li>网络空间数据</li><li>社交网络数据</li><li>位置轨迹数据</li><li>变化检测数据</li><li>与位置相关的空间媒体数据</li><li>人文地理数据</li><li>政府部门数据</li><li>空间飞行器数据</li><li>空间环境数据</li><li>海洋水文数据</li></ul></li></ul></li><li><p>时空大数据的基本特征：</p><ul><li>位置：点、线、面、体的三维位置（x，y，z）拓扑、方向、度量很复杂</li><li>时间：位置、属性等随时间变化而变化</li><li>属性：每个位置点、线、面、体上都有自己的数量、质量特征和说明性信息</li><li>尺度：空间尺度变化，即比例尺变化</li><li>多源异构：空间基准、时间、尺度、语义等不一致</li><li>多维：所有大数据与空间数据集成构成空间数据立方体，即“多维”可视化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时空大数据 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜狐面试题</title>
      <link href="/2019/10/28/SOHU-Question/"/>
      <url>/2019/10/28/SOHU-Question/</url>
      
        <content type="html"><![CDATA[<p>人生参加的第一次招聘，遇到一道不错的好题分享给大家：<br>求数组[6,3,1,2,5]中最长的数值连续子序列的长度<br>本人答案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(lyst)</span>:</span></span><br><span class="line">    copyBuffer = np.zeros(len(lyst), dtype=int)</span><br><span class="line">    mergeSortHelper(lyst, copyBuffer, <span class="number">0</span>, len(lyst) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSortHelper</span><span class="params">(lyst, copyBuffer, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        middle = (low + high) // <span class="number">2</span></span><br><span class="line">        mergeSortHelper(lyst, copyBuffer, low, middle)</span><br><span class="line">        mergeSortHelper(lyst, copyBuffer, middle + <span class="number">1</span>, high)</span><br><span class="line">        merge(lyst, copyBuffer, low, middle, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(lyst, copyBuffer, low, middle, high)</span>:</span></span><br><span class="line">    i1 = low</span><br><span class="line">    i2 = middle + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(low, high + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i1 &gt; middle:</span><br><span class="line">            copyBuffer[i] = lyst[i2]</span><br><span class="line">            i2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i2 &gt; high:</span><br><span class="line">            copyBuffer[i] = lyst[i1]</span><br><span class="line">            i1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> lyst[i1] &lt; lyst[i2]:</span><br><span class="line">            copyBuffer[i] = lyst[i1]</span><br><span class="line">            i1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            copyBuffer[i] = lyst[i2]</span><br><span class="line">            i2 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(low, high + <span class="number">1</span>):</span><br><span class="line">        lyst[i] = copyBuffer[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(lyst)</span>:</span></span><br><span class="line">    mergeSort(lyst)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    start = i</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    lengest = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(lyst)<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">if</span> lyst[i + <span class="number">1</span>] == lyst[i] + <span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum = i - start + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sum &gt; lengest:</span><br><span class="line">                lengest = sum</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            start = i</span><br><span class="line">    sum = i - start + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> sum &gt; lengest:</span><br><span class="line">        lengest = sum</span><br><span class="line">    <span class="keyword">return</span> lengest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面经 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次SDN踩坑</title>
      <link href="/2018/11/18/A-SDN-Problem/"/>
      <url>/2018/11/18/A-SDN-Problem/</url>
      
        <content type="html"><![CDATA[<p>很可能某些功能因为下载失败而不存在。 在这种情况下，根据karaf上的错误消息，将在Eclipse文件夹中删除项目的相应功能，然后重新建立该项目，以便该项目可以自动下载并再次添加功能。 将有很大的机会解决这个错误。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
